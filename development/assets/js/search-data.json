{"0": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "HF-MAX22200 Driver",
    "content": "Portable C++20 driver for the MAX22200 octal solenoid and motor driver with SPI interface . ",
    "url": "/hf-max22200-driver/development/#hf-max22200-driver",
    
    "relUrl": "/#hf-max22200-driver"
  },"1": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üìö Table of Contents",
    "content": ". | Overview | Features | Quick Start | Installation | API Reference | Examples | Documentation | Contributing | License | . ",
    "url": "/hf-max22200-driver/development/#-table-of-contents",
    
    "relUrl": "/#-table-of-contents"
  },"2": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üì¶ Overview",
    "content": "üìñ üìöüåê Live Complete Documentation - Interactive guides, examples, and step-by-step tutorials . HF-MAX22200 is a portable C++20 driver for the MAX22200 octal (eight-channel) solenoid and motor driver IC. The MAX22200 features eight half-bridges, each capable of handling up to 36V and 1A RMS, with integrated current sensing, current/voltage regulation, and comprehensive protection features. The driver uses a CRTP-based SpiInterface for hardware abstraction, allowing it to run on any platform (ESP32, STM32, Arduino, etc.) with zero runtime overhead. It implements all major features from the MAX22200 datasheet including channel configuration, current/voltage regulation modes, integrated current sensing (ICS), fault detection, and callback support for event-driven programming. ",
    "url": "/hf-max22200-driver/development/#-overview",
    
    "relUrl": "/#-overview"
  },"3": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "‚ú® Features",
    "content": ". | ‚úÖ Eight Half-Bridges: Each channel handles up to 36V and 1A RMS | ‚úÖ Current and Voltage Regulation: Supports both CDR (Current Drive Regulation) and VDR (Voltage Drive Regulation) modes | ‚úÖ Integrated Current Sensing (ICS): Real-time current monitoring without external sense resistors | ‚úÖ Half-Bridge and Full-Bridge Modes: Flexible bridge configurations | ‚úÖ HIT/HOLD Current Control: Programmable hit current, hold current, and hit time | ‚úÖ Comprehensive Protection: OCP, OL, DPM, UVLO, TSD, and fault registers | ‚úÖ Hardware Agnostic: SPI interface for platform independence | ‚úÖ Modern C++: C++20 with CRTP-based design | ‚úÖ Zero Overhead: CRTP-based design for compile-time polymorphism | ‚úÖ Callback Support: Event-driven programming with fault and state callbacks | ‚úÖ Statistics Tracking: Runtime performance and error monitoring | . ",
    "url": "/hf-max22200-driver/development/#-features",
    
    "relUrl": "/#-features"
  },"4": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üöÄ Quick Start",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 . | #include \"max22200.hpp\" // 1. Implement the SPI interface (see platform_integration.md) class MySpi : public max22200::SpiInterface&lt;MySpi&gt; { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Your SPI transfer implementation } }; // 2. Create driver instance MySpi spi; max22200::MAX22200 driver(spi); // 3. Initialize if (driver.Initialize() == max22200::DriverStatus::OK) { // 4. Configure channel 0 max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.hit_current = 500; config.hold_current = 200; config.hit_time = 1000; driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); } . | . For detailed setup, see Installation and Quick Start Guide. ",
    "url": "/hf-max22200-driver/development/#-quick-start",
    
    "relUrl": "/#-quick-start"
  },"5": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üîß Installation",
    "content": ". | Clone or copy the driver files into your project | Implement the SPI interface for your platform (see Platform Integration) | Include the header in your code: | 1 . | #include \"max22200.hpp\" . | . | Compile with a C++20 or newer compiler | . For detailed installation instructions, see docs/installation.md. ",
    "url": "/hf-max22200-driver/development/#-installation",
    
    "relUrl": "/#-installation"
  },"6": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üìñ API Reference",
    "content": "| Method | Description | . | Initialize() | Initialize the driver | . | Deinitialize() | Safely shut down the driver | . | Reset() | Perform software reset | . | ConfigureChannel() | Configure a channel | . | EnableChannel() | Enable/disable a channel | . | GetChannelStatus() | Get channel status | . | GetFaultStatus() | Get fault status | . | ReadCurrent() | Read current via ICS | . | SetSleepMode() | Enable/disable sleep mode | . | SetFaultCallback() | Set fault callback function | . | GetStatistics() | Get driver statistics | . For complete API documentation, see docs/api_reference.md. ",
    "url": "/hf-max22200-driver/development/#-api-reference",
    
    "relUrl": "/#-api-reference"
  },"7": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üìä Examples",
    "content": "For ESP32 examples, see the examples/esp32 directory. Additional examples for other platforms are available in the examples directory. Detailed example walkthroughs are available in docs/examples.md. ",
    "url": "/hf-max22200-driver/development/#-examples",
    
    "relUrl": "/#-examples"
  },"8": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üìö Documentation",
    "content": "For complete documentation, see the docs directory. ",
    "url": "/hf-max22200-driver/development/#-documentation",
    
    "relUrl": "/#-documentation"
  },"9": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "ü§ù Contributing",
    "content": "Pull requests and suggestions are welcome! Please follow the existing code style and include tests for new features. ",
    "url": "/hf-max22200-driver/development/#-contributing",
    
    "relUrl": "/#-contributing"
  },"10": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üìÑ License",
    "content": "This project is licensed under the GNU General Public License v3.0. See the LICENSE file for details. ",
    "url": "/hf-max22200-driver/development/#-license",
    
    "relUrl": "/#-license"
  },"11": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "HardFOC MAX22200 Driver",
    "content": " ",
    "url": "/hf-max22200-driver/development/",
    
    "relUrl": "/"
  },"12": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Configuration",
    "content": "This guide covers all configuration options available for the MAX22200 driver. ",
    "url": "/hf-max22200-driver/development/docs/configuration/#configuration",
    
    "relUrl": "/docs/configuration/#configuration"
  },"13": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Channel Configuration",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/configuration/#channel-configuration",
    
    "relUrl": "/docs/configuration/#channel-configuration"
  },"14": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Basic Channel Setup",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 . | max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; // Current Drive Regulation config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.parallel_mode = false; config.polarity = max22200::OutputPolarity::NORMAL; config.hit_current = 500; // Hit current (0-1023) config.hold_current = 200; // Hold current (0-1023) config.hit_time = 1000; // Hit time in ms (0-65535) driver.ConfigureChannel(0, config); . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#basic-channel-setup",
    
    "relUrl": "/docs/configuration/#basic-channel-setup"
  },"15": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Drive Modes",
    "content": "CDR (Current Drive Regulation) . | 1 . | config.drive_mode = max22200::DriveMode::CDR; . | . | Regulates current to hit_current during hit phase | Regulates current to hold_current during hold phase | Best for solenoids and motors requiring constant current | . VDR (Voltage Drive Regulation) . | 1 . | config.drive_mode = max22200::DriveMode::VDR; . | . | Applies constant voltage during hit phase | Regulates current to hold_current during hold phase | Best for applications requiring fast response | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#drive-modes",
    
    "relUrl": "/docs/configuration/#drive-modes"
  },"16": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Bridge Modes",
    "content": "Half-Bridge Mode . | 1 . | config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; . | . | Load connected between OUTA and GND | OUTB not used | Single-ended drive | . Full-Bridge Mode . | 1 . | config.bridge_mode = max22200::BridgeMode::FULL_BRIDGE; . | . | Load connected between OUTA and OUTB | Bidirectional drive | Can reverse current direction | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#bridge-modes",
    
    "relUrl": "/docs/configuration/#bridge-modes"
  },"17": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Current Settings",
    "content": "| 1 2 3 4 5 6 . | // Set hit and hold currents separately driver.SetHitCurrent(0, 500); // Channel 0, 500 mA driver.SetHoldCurrent(0, 200); // Channel 0, 200 mA // Or set both at once driver.SetCurrents(0, 500, 200); // Channel 0, hit=500mA, hold=200mA . | . Current Range: 0-1023 (10-bit resolution) . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#current-settings",
    
    "relUrl": "/docs/configuration/#current-settings"
  },"18": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Hit Time",
    "content": "| 1 . | driver.SetHitTime(0, 1000); // Channel 0, 1000 ms . | . Time Range: 0-65535 ms . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#hit-time",
    
    "relUrl": "/docs/configuration/#hit-time"
  },"19": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Global Configuration",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/configuration/#global-configuration",
    
    "relUrl": "/docs/configuration/#global-configuration"
  },"20": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Global Settings",
    "content": "| 1 2 3 4 5 6 7 8 . | max22200::GlobalConfig global_config; global_config.reset = false; global_config.sleep_mode = false; global_config.diagnostic_enable = true; global_config.ics_enable = true; // Integrated Current Sensing global_config.daisy_chain_mode = false; driver.ConfigureGlobal(global_config); . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#global-settings",
    
    "relUrl": "/docs/configuration/#global-settings"
  },"21": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Sleep Mode",
    "content": "| 1 2 . | driver.SetSleepMode(true); // Enable sleep mode driver.SetSleepMode(false); // Disable sleep mode . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#sleep-mode",
    
    "relUrl": "/docs/configuration/#sleep-mode"
  },"22": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Diagnostic Mode",
    "content": "| 1 . | driver.SetDiagnosticMode(true); // Enable diagnostics . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#diagnostic-mode",
    
    "relUrl": "/docs/configuration/#diagnostic-mode"
  },"23": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Integrated Current Sensing (ICS)",
    "content": "| 1 . | driver.SetIntegratedCurrentSensing(true); // Enable ICS . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#integrated-current-sensing-ics",
    
    "relUrl": "/docs/configuration/#integrated-current-sensing-ics"
  },"24": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Channel Control",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/configuration/#channel-control",
    
    "relUrl": "/docs/configuration/#channel-control"
  },"25": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Enable/Disable Channels",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 . | // Enable single channel driver.EnableChannel(0, true); // Disable single channel driver.EnableChannel(0, false); // Enable all channels driver.EnableAllChannels(true); // Disable all channels driver.EnableAllChannels(false); . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#enabledisable-channels",
    
    "relUrl": "/docs/configuration/#enabledisable-channels"
  },"26": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Individual Channel Settings",
    "content": "| 1 2 3 4 5 6 7 8 . | // Set drive mode driver.SetChannelDriveMode(0, max22200::DriveMode::CDR); // Set bridge mode driver.SetChannelBridgeMode(0, max22200::BridgeMode::FULL_BRIDGE); // Set polarity driver.SetChannelPolarity(0, max22200::OutputPolarity::INVERTED); . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#individual-channel-settings",
    
    "relUrl": "/docs/configuration/#individual-channel-settings"
  },"27": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Recommended Settings",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/configuration/#recommended-settings",
    
    "relUrl": "/docs/configuration/#recommended-settings"
  },"28": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Solenoid Control",
    "content": "| 1 2 3 4 5 6 7 . | max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 800; // High current for pull-in config.hold_current = 200; // Lower current for holding config.hit_time = 50; // Short hit time . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#for-solenoid-control",
    
    "relUrl": "/docs/configuration/#for-solenoid-control"
  },"29": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Motor Control",
    "content": "| 1 2 3 4 5 6 7 . | max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::FULL_BRIDGE; config.hit_current = 500; config.hold_current = 500; config.hit_time = 0; // Continuous operation . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#for-motor-control",
    
    "relUrl": "/docs/configuration/#for-motor-control"
  },"30": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "For Low-Power Applications",
    "content": "| 1 2 3 4 5 6 7 . | max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::VDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 300; config.hold_current = 100; config.hit_time = 100; . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#for-low-power-applications",
    
    "relUrl": "/docs/configuration/#for-low-power-applications"
  },"31": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Next Steps",
    "content": ". | See Examples for configuration examples | Review API Reference for all configuration methods | . Navigation ‚¨ÖÔ∏è Platform Integration | Next: API Reference ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#next-steps",
    
    "relUrl": "/docs/configuration/#next-steps"
  },"32": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "‚öôÔ∏è Configuration",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/configuration/",
    
    "relUrl": "/docs/configuration/"
  },"33": {
    "doc": "üí° Examples",
    "title": "Examples",
    "content": "This guide provides complete, working examples demonstrating various use cases for the MAX22200 driver. ",
    "url": "/hf-max22200-driver/development/docs/examples/#examples",
    
    "relUrl": "/docs/examples/#examples"
  },"34": {
    "doc": "üí° Examples",
    "title": "Example 1: Basic Solenoid Control",
    "content": "This example shows basic solenoid control with hit and hold currents. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 . | #include \"max22200.hpp\" #include \"esp32_max22200_spi.hpp\" void app_main() { // 1. Configure SPI Esp32Max22200Spi::SPIConfig spi_config; spi_config.host = SPI2_HOST; spi_config.miso_pin = GPIO_NUM_2; spi_config.mosi_pin = GPIO_NUM_7; spi_config.sclk_pin = GPIO_NUM_6; spi_config.cs_pin = GPIO_NUM_10; spi_config.frequency = 10000000; spi_config.mode = 0; Esp32Max22200Spi spi(spi_config); spi.Initialize(); // 2. Create driver max22200::MAX22200 driver(spi); // 3. Initialize if (driver.Initialize() != max22200::DriverStatus::OK) { printf(\"Initialization failed\\n\"); return; } // 4. Configure channel 0 for solenoid max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 800; // 800 mA hit current config.hold_current = 200; // 200 mA hold current config.hit_time = 50; // 50 ms hit time driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); printf(\"Solenoid enabled\\n\"); } . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-1-basic-solenoid-control",
    
    "relUrl": "/docs/examples/#example-1-basic-solenoid-control"
  },"35": {
    "doc": "üí° Examples",
    "title": "Example 2: Motor Control with Full-Bridge",
    "content": "This example demonstrates motor control using full-bridge mode. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 . | #include \"max22200.hpp\" void app_main() { // ... SPI setup (same as Example 1) max22200::MAX22200 driver(spi); driver.Initialize(); // Configure channel 0 for motor max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::FULL_BRIDGE; config.hit_current = 500; config.hold_current = 500; config.hit_time = 0; // Continuous operation driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); // Read current uint16_t current; if (driver.ReadCurrent(0, current) == max22200::DriverStatus::OK) { printf(\"Motor current: %u mA\\n\", current); } } . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-2-motor-control-with-full-bridge",
    
    "relUrl": "/docs/examples/#example-2-motor-control-with-full-bridge"
  },"36": {
    "doc": "üí° Examples",
    "title": "Example 3: Fault Handling with Callbacks",
    "content": "This example shows how to handle faults using callbacks. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 . | #include \"max22200.hpp\" void fault_handler(uint8_t channel, max22200::FaultType fault_type, void *user_data) { const char* fault_names[] = { \"OCP\", \"OL\", \"DPM\", \"UVLO\", \"HHF\", \"TSD\" }; printf(\"Fault on channel %d: %s\\n\", channel, fault_names[static_cast&lt;int&gt;(fault_type)]); } void app_main() { // ... SPI setup max22200::MAX22200 driver(spi); driver.Initialize(); // Set fault callback driver.SetFaultCallback(fault_handler); // Configure and enable channel max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.hit_current = 500; config.hold_current = 200; driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); // Monitor for faults while (true) { max22200::FaultStatus faults; driver.ReadFaultStatus(faults); if (faults.hasFault()) { printf(\"Fault detected: %d faults\\n\", faults.getFaultCount()); } vTaskDelay(pdMS_TO_TICKS(100)); } } . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-3-fault-handling-with-callbacks",
    
    "relUrl": "/docs/examples/#example-3-fault-handling-with-callbacks"
  },"37": {
    "doc": "üí° Examples",
    "title": "Example 4: Multiple Channels",
    "content": "This example demonstrates controlling multiple channels. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 . | #include \"max22200.hpp\" void app_main() { // ... SPI setup max22200::MAX22200 driver(spi); driver.Initialize(); // Configure multiple channels for (uint8_t ch = 0; ch &lt; 8; ch++) { max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 500; config.hold_current = 200; config.hit_time = 100; driver.ConfigureChannel(ch, config); } // Enable all channels driver.EnableAllChannels(true); // Read status of all channels max22200::ChannelStatusArray statuses; driver.ReadAllChannelStatuses(statuses); for (uint8_t ch = 0; ch &lt; 8; ch++) { printf(\"Channel %d: enabled=%d, current=%u\\n\", ch, statuses[ch].enabled, statuses[ch].current_reading); } } . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-4-multiple-channels",
    
    "relUrl": "/docs/examples/#example-4-multiple-channels"
  },"38": {
    "doc": "üí° Examples",
    "title": "Example 5: Current Monitoring",
    "content": "This example demonstrates continuous current monitoring. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 . | #include \"max22200.hpp\" void app_main() { // ... SPI setup max22200::MAX22200 driver(spi); driver.Initialize(); // Enable ICS driver.SetIntegratedCurrentSensing(true); // Configure channel max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.hit_current = 500; config.hold_current = 200; driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); // Monitor current while (true) { uint16_t current; if (driver.ReadCurrent(0, current) == max22200::DriverStatus::OK) { printf(\"Current: %u mA\\n\", current); } vTaskDelay(pdMS_TO_TICKS(100)); } } . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-5-current-monitoring",
    
    "relUrl": "/docs/examples/#example-5-current-monitoring"
  },"39": {
    "doc": "üí° Examples",
    "title": "Running the Examples",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/examples/#running-the-examples",
    
    "relUrl": "/docs/examples/#running-the-examples"
  },"40": {
    "doc": "üí° Examples",
    "title": "ESP32",
    "content": "| 1 2 . | cd examples/esp32 idf.py build flash monitor . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#esp32",
    
    "relUrl": "/docs/examples/#esp32"
  },"41": {
    "doc": "üí° Examples",
    "title": "Other Platforms",
    "content": "For other platforms, implement the SPI interface and compile with C++20 support. ",
    "url": "/hf-max22200-driver/development/docs/examples/#other-platforms",
    
    "relUrl": "/docs/examples/#other-platforms"
  },"42": {
    "doc": "üí° Examples",
    "title": "Next Steps",
    "content": ". | Review the API Reference for method details | Check Troubleshooting if you encounter issues | Explore the examples directory for more examples | . Navigation ‚¨ÖÔ∏è API Reference | Next: Troubleshooting ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-max22200-driver/development/docs/examples/#next-steps",
    
    "relUrl": "/docs/examples/#next-steps"
  },"43": {
    "doc": "üí° Examples",
    "title": "üí° Examples",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/examples/",
    
    "relUrl": "/docs/examples/"
  },"44": {
    "doc": "üîå Hardware Setup",
    "title": "Hardware Setup",
    "content": "This guide covers the physical connections and hardware requirements for the MAX22200 octal solenoid and motor driver chip. ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#hardware-setup",
    
    "relUrl": "/docs/hardware_setup/#hardware-setup"
  },"45": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Connections",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#pin-connections",
    
    "relUrl": "/docs/hardware_setup/#pin-connections"
  },"46": {
    "doc": "üîå Hardware Setup",
    "title": "Basic SPI Connections",
    "content": "| 1 2 3 4 5 6 7 8 . | MCU MAX22200 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VDD GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GND SCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SCLK MOSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDI MISO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDO CS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CS . | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#basic-spi-connections",
    
    "relUrl": "/docs/hardware_setup/#basic-spi-connections"
  },"47": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Descriptions",
    "content": "| Pin | Name | Description | Required | . | VDD | Power | 3.3V power supply (2.7V - 5.5V) | Yes | . | GND | Ground | Ground reference | Yes | . | SCLK | Clock | SPI clock line | Yes | . | SDI | Data In | SPI data input (from MCU) | Yes | . | SDO | Data Out | SPI data output (to MCU) | Yes | . | CS | Chip Select | SPI chip select (active low) | Yes | . | FAULT | Fault | Fault interrupt output (optional) | No | . | RESET | Reset | Reset input (optional) | No | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#pin-descriptions",
    
    "relUrl": "/docs/hardware_setup/#pin-descriptions"
  },"48": {
    "doc": "üîå Hardware Setup",
    "title": "Channel Output Pins",
    "content": "Each of the 8 channels has two output pins: . | Channel | OUTA | OUTB | . | 0 | OUT0A | OUT0B | . | 1 | OUT1A | OUT1B | . | 2 | OUT2A | OUT2B | . | 3 | OUT3A | OUT3B | . | 4 | OUT4A | OUT4B | . | 5 | OUT5A | OUT5B | . | 6 | OUT6A | OUT6B | . | 7 | OUT7A | OUT7B | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#channel-output-pins",
    
    "relUrl": "/docs/hardware_setup/#channel-output-pins"
  },"49": {
    "doc": "üîå Hardware Setup",
    "title": "Power Requirements",
    "content": ". | Supply Voltage: 2.7V - 5.5V (3.3V or 5V typical) | Current Consumption: Depends on load, up to 1A RMS per channel | Power Supply: Clean supply with decoupling capacitors (100nF ceramic + 10¬µF tantalum recommended per channel) | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#power-requirements",
    
    "relUrl": "/docs/hardware_setup/#power-requirements"
  },"50": {
    "doc": "üîå Hardware Setup",
    "title": "SPI Configuration",
    "content": ". | Mode: SPI Mode 0 (CPOL=0, CPHA=0) or Mode 3 (CPOL=1, CPHA=1) | Speed: Up to 10 MHz | Bit Order: MSB first | CS Polarity: Active low (CS) | Data Format: 8-bit data words | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#spi-configuration",
    
    "relUrl": "/docs/hardware_setup/#spi-configuration"
  },"51": {
    "doc": "üîå Hardware Setup",
    "title": "Load Connections",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#load-connections",
    
    "relUrl": "/docs/hardware_setup/#load-connections"
  },"52": {
    "doc": "üîå Hardware Setup",
    "title": "Half-Bridge Mode",
    "content": "In half-bridge mode, connect the load between OUTA and GND: . | 1 2 . | OUTA ‚îÄ‚îÄ‚îÄ‚îÄ[Load]‚îÄ‚îÄ‚îÄ‚îÄ GND OUTB ‚îÄ‚îÄ‚îÄ‚îÄ (not used) . | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#half-bridge-mode",
    
    "relUrl": "/docs/hardware_setup/#half-bridge-mode"
  },"53": {
    "doc": "üîå Hardware Setup",
    "title": "Full-Bridge Mode",
    "content": "In full-bridge mode, connect the load between OUTA and OUTB: . | 1 . | OUTA ‚îÄ‚îÄ‚îÄ‚îÄ[Load]‚îÄ‚îÄ‚îÄ‚îÄ OUTB . | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#full-bridge-mode",
    
    "relUrl": "/docs/hardware_setup/#full-bridge-mode"
  },"54": {
    "doc": "üîå Hardware Setup",
    "title": "Physical Layout Recommendations",
    "content": ". | Keep SPI traces short (&lt; 10cm recommended) | Use ground plane for noise reduction | Place decoupling capacitors (100nF ceramic + 10¬µF tantalum) close to VDD pin | Route clock and data lines away from noise sources | Keep high-current traces (OUTA/OUTB) away from sensitive signals | Use appropriate trace widths for high-current paths | Add flyback diodes for inductive loads (solenoids, motors) | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#physical-layout-recommendations",
    
    "relUrl": "/docs/hardware_setup/#physical-layout-recommendations"
  },"55": {
    "doc": "üîå Hardware Setup",
    "title": "Example Wiring Diagram",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . | MAX22200 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ VDD ‚îÇ GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ GND ‚îÇ SCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SCLK ‚îÇ MOSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SDI ‚îÇ MISO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SDO ‚îÇ CS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ CS ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ OUT0A ‚îú‚îÄ‚îÄ‚îÄ[Solenoid]‚îÄ‚îÄ‚îÄ GND ‚îÇ ‚îÇ OUT0B (not used in half-bridge) . | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#example-wiring-diagram",
    
    "relUrl": "/docs/hardware_setup/#example-wiring-diagram"
  },"56": {
    "doc": "üîå Hardware Setup",
    "title": "Protection Components",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#protection-components",
    
    "relUrl": "/docs/hardware_setup/#protection-components"
  },"57": {
    "doc": "üîå Hardware Setup",
    "title": "Flyback Diodes",
    "content": "For inductive loads (solenoids, motors), add flyback diodes: . | 1 2 . | OUTA ‚îÄ‚îÄ‚îÄ‚îÄ[Flyback Diode]‚îÄ‚îÄ‚îÄ OUTB (cathode to OUTA) . | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#flyback-diodes",
    
    "relUrl": "/docs/hardware_setup/#flyback-diodes"
  },"58": {
    "doc": "üîå Hardware Setup",
    "title": "Current Limiting",
    "content": "The MAX22200 has built-in overcurrent protection (OCP), but you may want to add external current limiting for additional safety. ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#current-limiting",
    
    "relUrl": "/docs/hardware_setup/#current-limiting"
  },"59": {
    "doc": "üîå Hardware Setup",
    "title": "Next Steps",
    "content": ". | Verify connections with a multimeter | Proceed to Quick Start to test the connection | Review Platform Integration for software setup | . Navigation ‚¨ÖÔ∏è Quick Start | Next: Platform Integration ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#next-steps",
    
    "relUrl": "/docs/hardware_setup/#next-steps"
  },"60": {
    "doc": "üîå Hardware Setup",
    "title": "üîå Hardware Setup",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/",
    
    "relUrl": "/docs/hardware_setup/"
  },"61": {
    "doc": "üìö Documentation",
    "title": "HF-MAX22200 Documentation",
    "content": "Welcome! This directory contains step-by-step guides for installing, building, and using the HF-MAX22200 library. ",
    "url": "/hf-max22200-driver/development/docs/#hf-max22200-documentation",
    
    "relUrl": "/docs/#hf-max22200-documentation"
  },"62": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation Structure",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/#-documentation-structure",
    
    "relUrl": "/docs/#-documentation-structure"
  },"63": {
    "doc": "üìö Documentation",
    "title": "Getting Started",
    "content": ". | üõ†Ô∏è Installation ‚Äì Prerequisites and how to obtain the source | ‚ö° Quick Start ‚Äì Minimal working example to get you running | üîå Hardware Setup ‚Äì Wiring diagrams and pin connections | . ",
    "url": "/hf-max22200-driver/development/docs/#getting-started",
    
    "relUrl": "/docs/#getting-started"
  },"64": {
    "doc": "üìö Documentation",
    "title": "Integration",
    "content": ". | üîß Platform Integration ‚Äì Implement the CRTP SPI interface for your platform | ‚öôÔ∏è Configuration ‚Äì Configuration options and settings | . ",
    "url": "/hf-max22200-driver/development/docs/#integration",
    
    "relUrl": "/docs/#integration"
  },"65": {
    "doc": "üìö Documentation",
    "title": "Reference",
    "content": ". | üìñ API Reference ‚Äì Complete API documentation | üí° Examples ‚Äì Detailed example walkthroughs | . ",
    "url": "/hf-max22200-driver/development/docs/#reference",
    
    "relUrl": "/docs/#reference"
  },"66": {
    "doc": "üìö Documentation",
    "title": "Troubleshooting",
    "content": ". | üêõ Troubleshooting ‚Äì Common issues and solutions | . ",
    "url": "/hf-max22200-driver/development/docs/#troubleshooting",
    
    "relUrl": "/docs/#troubleshooting"
  },"67": {
    "doc": "üìö Documentation",
    "title": "üöÄ Quick Start Path",
    "content": "New to MAX22200? Follow this recommended path: . | Start with Installation to prepare your environment | Follow Hardware Setup to wire your hardware | Read Quick Start for a minimal working example | Check Platform Integration to implement the SPI interface | Explore Examples for more advanced usage | . ",
    "url": "/hf-max22200-driver/development/docs/#-quick-start-path",
    
    "relUrl": "/docs/#-quick-start-path"
  },"68": {
    "doc": "üìö Documentation",
    "title": "üí° Need Help?",
    "content": ". | üêõ Found a bug? Check the Troubleshooting guide | ‚ùì Have questions? Review the API Reference | üìù Want to contribute? See the contributing guidelines in the main README | . Navigation ‚û°Ô∏è Installation . ",
    "url": "/hf-max22200-driver/development/docs/#-need-help",
    
    "relUrl": "/docs/#-need-help"
  },"69": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/",
    
    "relUrl": "/docs/"
  },"70": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Installation",
    "content": "This guide covers how to obtain and integrate the MAX22200 driver library into your project. ",
    "url": "/hf-max22200-driver/development/docs/installation/#installation",
    
    "relUrl": "/docs/installation/#installation"
  },"71": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Prerequisites",
    "content": "Before installing the driver, ensure you have: . | C++20 Compiler: GCC 10+, Clang 12+, or MSVC 2019+ | Build System: Make, CMake, or ESP-IDF (depending on your platform) | Platform SDK: ESP-IDF, STM32 HAL, Arduino, or your platform‚Äôs SPI driver | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#prerequisites",
    
    "relUrl": "/docs/installation/#prerequisites"
  },"72": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Obtaining the Source",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/installation/#obtaining-the-source",
    
    "relUrl": "/docs/installation/#obtaining-the-source"
  },"73": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 1: Git Clone",
    "content": "| 1 2 . | git clone https://github.com/n3b3x/hf-max22200-driver.git cd hf-max22200-driver . | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#option-1-git-clone",
    
    "relUrl": "/docs/installation/#option-1-git-clone"
  },"74": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 2: Copy Files",
    "content": "Copy the following files into your project: . | 1 2 3 4 5 6 7 . | inc/ ‚îú‚îÄ‚îÄ max22200.hpp ‚îú‚îÄ‚îÄ max22200_spi_interface.hpp ‚îú‚îÄ‚îÄ max22200_registers.hpp ‚îî‚îÄ‚îÄ max22200_types.hpp src/ ‚îî‚îÄ‚îÄ max22200.cpp . | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#option-2-copy-files",
    
    "relUrl": "/docs/installation/#option-2-copy-files"
  },"75": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Integration Methods",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/installation/#integration-methods",
    
    "relUrl": "/docs/installation/#integration-methods"
  },"76": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Using CMake",
    "content": "Add the driver as a subdirectory in your CMakeLists.txt: . | 1 2 3 4 5 . | add_subdirectory(external/hf-max22200-driver) target_link_libraries(your_target PRIVATE hf_max22200) target_include_directories(your_target PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/external/hf-max22200-driver/inc ) . | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#using-cmake",
    
    "relUrl": "/docs/installation/#using-cmake"
  },"77": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Using ESP-IDF Component",
    "content": "The driver can be used as an ESP-IDF component. Add it to your components directory: . | 1 2 3 4 5 6 . | # In your main CMakeLists.txt idf_component_register( SRCS \"your_code.cpp\" INCLUDE_DIRS \".\" REQUIRES hf_max22200 ) . | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#using-esp-idf-component",
    
    "relUrl": "/docs/installation/#using-esp-idf-component"
  },"78": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Manual Integration",
    "content": ". | Copy the driver files to your project | Add the inc/ directory to your include path | Include the header: | 1 . | #include \"max22200.hpp\" . | . | Compile with C++20 support: | 1 . | g++ -std=c++20 -I inc/ your_code.cpp src/max22200.cpp . | . | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#manual-integration",
    
    "relUrl": "/docs/installation/#manual-integration"
  },"79": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Verification",
    "content": "To verify the installation: . | Include the header in a test file: | 1 . | #include \"max22200.hpp\" . | . | Compile a simple test: | 1 . | g++ -std=c++20 -I inc/ -c src/max22200.cpp -o test.o . | . | If compilation succeeds, the library is properly installed. | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#verification",
    
    "relUrl": "/docs/installation/#verification"
  },"80": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Next Steps",
    "content": ". | Follow the Quick Start guide to create your first application | Review Hardware Setup for wiring instructions | Check Platform Integration to implement the SPI interface | . Navigation ‚¨ÖÔ∏è Back to Index | Next: Quick Start ‚û°Ô∏è . ",
    "url": "/hf-max22200-driver/development/docs/installation/#next-steps",
    
    "relUrl": "/docs/installation/#next-steps"
  },"81": {
    "doc": "üõ†Ô∏è Installation",
    "title": "üõ†Ô∏è Installation",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/installation/",
    
    "relUrl": "/docs/installation/"
  },"82": {
    "doc": "üîß Platform Integration",
    "title": "Platform Integration Guide",
    "content": "This guide explains how to implement the hardware abstraction interface for the MAX22200 driver on your platform. ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#platform-integration-guide",
    
    "relUrl": "/docs/platform_integration/#platform-integration-guide"
  },"83": {
    "doc": "üîß Platform Integration",
    "title": "Understanding CRTP (Curiously Recurring Template Pattern)",
    "content": "The MAX22200 driver uses CRTP (Curiously Recurring Template Pattern) for hardware abstraction. This design choice provides several critical benefits for embedded systems: . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern",
    
    "relUrl": "/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern"
  },"84": {
    "doc": "üîß Platform Integration",
    "title": "Why CRTP Instead of Virtual Functions?",
    "content": "1. Zero Runtime Overhead . | Virtual functions: Require a vtable lookup (indirect call) = ~5-10 CPU cycles overhead per call | CRTP: Direct function calls = 0 overhead, compiler can inline | Impact: In time-critical embedded code controlling solenoids/motors, this matters significantly | . 2. Compile-Time Polymorphism . | Virtual functions: Runtime dispatch - the compiler cannot optimize across the abstraction boundary | CRTP: Compile-time dispatch - full optimization, dead code elimination, constant propagation | Impact: Smaller code size, faster execution | . 3. Memory Efficiency . | Virtual functions: Each object needs a vtable pointer (4-8 bytes) | CRTP: No vtable pointer needed | Impact: Critical in memory-constrained systems | . 4. Type Safety . | Virtual functions: Runtime errors if method not implemented | CRTP: Compile-time errors if method not implemented | Impact: Catch bugs at compile time, not in the field | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#why-crtp-instead-of-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#why-crtp-instead-of-virtual-functions"
  },"85": {
    "doc": "üîß Platform Integration",
    "title": "How CRTP Works",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 . | // Base template class (from max22200_spi_interface.hpp) template &lt;typename Derived&gt; class SpiInterface { public: bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { // Cast 'this' to Derived* and call the derived implementation return static_cast&lt;Derived*&gt;(this)-&gt;Transfer(tx_data, rx_data, length); } }; // Your implementation class MySPI : public max22200::SpiInterface&lt;MySPI&gt; { public: // This method is called directly (no virtual overhead) bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { // Your platform-specific SPI code } }; ```cpp ## Interface Definition The MAX22200 driver requires you to implement the following interface: ```cpp template &lt;typename Derived&gt; class SpiInterface { public: // Required methods (implement all of these) bool Initialize(); bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length); void SetChipSelect(bool state); bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first = true); bool IsReady() const; }; ```cpp ## Implementation Steps ### Step 1: Create Your Implementation Class ```cpp #include \"max22200_spi_interface.hpp\" class MyPlatformSPI : public max22200::SpiInterface&lt;MyPlatformSPI&gt; { private: // Your platform-specific members spi_device_handle_t spi_device_; // Example for ESP32 public: // Constructor MyPlatformSPI(spi_device_handle_t device) : spi_device_(device) {} // Implement required methods bool Initialize() { // Your initialization code return true; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { // Your transfer code return true; } void SetChipSelect(bool state) { // Your CS control code } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // Your configuration code return true; } bool IsReady() const { // Check if SPI is ready return true; } }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#how-crtp-works",
    
    "relUrl": "/docs/platform_integration/#how-crtp-works"
  },"86": {
    "doc": "üîß Platform Integration",
    "title": "Step 2: Platform-Specific Examples",
    "content": "ESP32 (ESP-IDF) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 . | #include \"driver/spi_master.h\" #include \"max22200_spi_interface.hpp\" class Esp32SPIBus : public max22200::SpiInterface&lt;Esp32SPIBus&gt; { private: spi_device_handle_t spi_device_; gpio_num_t cs_pin_; public: Esp32SPIBus(spi_host_device_t host, const spi_device_interface_config_t&amp; config, gpio_num_t cs) { spi_bus_add_device(host, &amp;config, &amp;spi_device_); cs_pin_ = cs; } bool Initialize() { return spi_device_ != nullptr; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { spi_transaction_t trans = {}; trans.length = length * 8; trans.tx_buffer = tx_data; trans.rx_buffer = rx_data; esp_err_t ret = spi_device_transmit(spi_device_, &amp;trans); return ret == ESP_OK; } void SetChipSelect(bool state) { gpio_set_level(cs_pin_, state ? 0 : 1); // Active low } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // ESP-IDF handles this via device config return true; } bool IsReady() const { return spi_device_ != nullptr; } }; . | . STM32 (HAL) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 . | #include \"stm32f4xx_hal.h\" #include \"max22200_spi_interface.hpp\" extern SPI_HandleTypeDef hspi1; class STM32SPIBus : public max22200::SpiInterface&lt;STM32SPIBus&gt; { private: GPIO_TypeDef* cs_port_; uint16_t cs_pin_; public: STM32SPIBus(GPIO_TypeDef* cs_port, uint16_t cs_pin) : cs_port_(cs_port), cs_pin_(cs_pin) {} bool Initialize() { return HAL_SPI_Init(&amp;hspi1) == HAL_OK; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { SetChipSelect(true); // Assert CS HAL_StatusTypeDef status = HAL_SPI_TransmitReceive(&amp;hspi1, (uint8_t*)tx_data, rx_data, length, HAL_MAX_DELAY); SetChipSelect(false); // Deassert CS return status == HAL_OK; } void SetChipSelect(bool state) { HAL_GPIO_WritePin(cs_port_, cs_pin_, state ? GPIO_PIN_RESET : GPIO_PIN_SET); } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // STM32 HAL handles this via SPI init return true; } bool IsReady() const { return hspi1.State == HAL_SPI_STATE_READY; } }; . | . Arduino . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 . | #include &lt;SPI.h&gt; #include \"max22200_spi_interface.hpp\" class ArduinoSPIBus : public max22200::SpiInterface&lt;ArduinoSPIBus&gt; { private: uint8_t cs_pin_; public: ArduinoSPIBus(uint8_t cs_pin) : cs_pin_(cs_pin) { pinMode(cs_pin_, OUTPUT); digitalWrite(cs_pin_, HIGH); } bool Initialize() { SPI.begin(); return true; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { SPI.beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0)); SetChipSelect(true); for (size_t i = 0; i &lt; length; i++) { uint8_t byte = SPI.transfer(tx_data ? tx_data[i] : 0); if (rx_data) { rx_data[i] = byte; } } SetChipSelect(false); SPI.endTransaction(); return true; } void SetChipSelect(bool state) { digitalWrite(cs_pin_, state ? LOW : HIGH); // Active low } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // Arduino SPI handles this via beginTransaction return true; } bool IsReady() const { return true; } }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#step-2-platform-specific-examples",
    
    "relUrl": "/docs/platform_integration/#step-2-platform-specific-examples"
  },"87": {
    "doc": "üîß Platform Integration",
    "title": "Common Pitfalls",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#common-pitfalls",
    
    "relUrl": "/docs/platform_integration/#common-pitfalls"
  },"88": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Use Virtual Functions",
    "content": "| 1 2 3 4 5 6 7 . | // WRONG - defeats the purpose of CRTP class MyBus : public max22200::SpiInterface&lt;MyBus&gt; { public: virtual bool Transfer(...) override { // ‚ùå Virtual keyword not needed // ... } }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#-dont-use-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#-dont-use-virtual-functions"
  },"89": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct CRTP Implementation",
    "content": "| 1 2 3 4 5 6 7 . | // CORRECT - no virtual keyword class MyBus : public max22200::SpiInterface&lt;MyBus&gt; { public: bool Transfer(...) { // ‚úÖ Direct implementation // ... } }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#-correct-crtp-implementation",
    
    "relUrl": "/docs/platform_integration/#-correct-crtp-implementation"
  },"90": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Forget the Template Parameter",
    "content": "| 1 2 3 4 . | // WRONG - missing template parameter class MyBus : public max22200::SpiInterface { // ‚ùå Compiler error // ... }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#-dont-forget-the-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-dont-forget-the-template-parameter"
  },"91": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct Template Parameter",
    "content": "| 1 2 3 4 . | // CORRECT - pass your class as template parameter class MyBus : public max22200::SpiInterface&lt;MyBus&gt; { // ‚úÖ // ... }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#-correct-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-correct-template-parameter"
  },"92": {
    "doc": "üîß Platform Integration",
    "title": "Testing Your Implementation",
    "content": "After implementing the interface, test it: . | 1 2 3 4 5 6 7 8 9 . | MyPlatformSPI spi(/* your config */); max22200::MAX22200 driver(spi); if (driver.Initialize() == max22200::DriverStatus::OK) { // Test basic operations max22200::ChannelConfig config; config.enabled = true; driver.ConfigureChannel(0, config); } . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#testing-your-implementation",
    
    "relUrl": "/docs/platform_integration/#testing-your-implementation"
  },"93": {
    "doc": "üîß Platform Integration",
    "title": "Next Steps",
    "content": ". | See Configuration for driver configuration options | Check Examples for complete usage examples | Review API Reference for all available methods | . Navigation ‚¨ÖÔ∏è Hardware Setup | Next: Configuration ‚û°Ô∏è . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#next-steps",
    
    "relUrl": "/docs/platform_integration/#next-steps"
  },"94": {
    "doc": "üîß Platform Integration",
    "title": "üîß Platform Integration",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/",
    
    "relUrl": "/docs/platform_integration/"
  },"95": {
    "doc": "‚ö° Quick Start",
    "title": "Quick Start",
    "content": "This guide will get you up and running with the MAX22200 driver in just a few steps. ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#quick-start",
    
    "relUrl": "/docs/quickstart/#quick-start"
  },"96": {
    "doc": "‚ö° Quick Start",
    "title": "Prerequisites",
    "content": ". | Driver installed | Hardware wired | SPI interface implemented | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#prerequisites",
    
    "relUrl": "/docs/quickstart/#prerequisites"
  },"97": {
    "doc": "‚ö° Quick Start",
    "title": "Minimal Example",
    "content": "Here‚Äôs a complete working example: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 . | #include \"max22200.hpp\" // 1. Implement the SPI interface class MySpi : public max22200::SpiInterface&lt;MySpi&gt; { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Your SPI transfer implementation // Assert CS, transfer data, deassert CS } }; // 2. Create instances MySpi spi; max22200::MAX22200 driver(spi); // 3. Initialize if (driver.Initialize() == max22200::DriverStatus::OK) { // 4. Configure channel 0 max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 500; // 500 mA hit current config.hold_current = 200; // 200 mA hold current config.hit_time = 1000; // 1000 ms hit time driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); } . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#minimal-example",
    
    "relUrl": "/docs/quickstart/#minimal-example"
  },"98": {
    "doc": "‚ö° Quick Start",
    "title": "Step-by-Step Explanation",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-by-step-explanation",
    
    "relUrl": "/docs/quickstart/#step-by-step-explanation"
  },"99": {
    "doc": "‚ö° Quick Start",
    "title": "Step 1: Include the Header",
    "content": "| 1 . | #include \"max22200.hpp\" . | . This includes the main driver class and all necessary types. ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-1-include-the-header",
    
    "relUrl": "/docs/quickstart/#step-1-include-the-header"
  },"100": {
    "doc": "‚ö° Quick Start",
    "title": "Step 2: Implement the SPI Interface",
    "content": "You need to implement the SpiInterface for your platform. See Platform Integration for detailed examples. | 1 2 3 4 5 6 7 8 . | class MySpi : public max22200::SpiInterface&lt;MySpi&gt; { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Assert chip select // Perform SPI transfer // Deassert chip select } }; . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-2-implement-the-spi-interface",
    
    "relUrl": "/docs/quickstart/#step-2-implement-the-spi-interface"
  },"101": {
    "doc": "‚ö° Quick Start",
    "title": "Step 3: Create Driver Instance",
    "content": "| 1 2 . | MySpi spi; max22200::MAX22200 driver(spi); . | . The constructor takes a reference to your SPI interface implementation. ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-3-create-driver-instance",
    
    "relUrl": "/docs/quickstart/#step-3-create-driver-instance"
  },"102": {
    "doc": "‚ö° Quick Start",
    "title": "Step 4: Initialize",
    "content": "| 1 2 3 . | if (driver.Initialize() == max22200::DriverStatus::OK) { // Driver is ready } . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-4-initialize",
    
    "relUrl": "/docs/quickstart/#step-4-initialize"
  },"103": {
    "doc": "‚ö° Quick Start",
    "title": "Step 5: Configure Channel",
    "content": "| 1 2 3 4 5 6 7 8 9 . | max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; // Current Drive Regulation config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 500; // Hit current in mA (0-1023) config.hold_current = 200; // Hold current in mA (0-1023) config.hit_time = 1000; // Hit time in ms (0-65535) driver.ConfigureChannel(0, config); . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-5-configure-channel",
    
    "relUrl": "/docs/quickstart/#step-5-configure-channel"
  },"104": {
    "doc": "‚ö° Quick Start",
    "title": "Step 6: Enable Channel",
    "content": "| 1 . | driver.EnableChannel(0, true); . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-6-enable-channel",
    
    "relUrl": "/docs/quickstart/#step-6-enable-channel"
  },"105": {
    "doc": "‚ö° Quick Start",
    "title": "Complete Example with Error Handling",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 . | #include \"max22200.hpp\" class MySpi : public max22200::SpiInterface&lt;MySpi&gt; { // ... SPI implementation }; void app_main() { MySpi spi; max22200::MAX22200 driver(spi); // Initialize max22200::DriverStatus status = driver.Initialize(); if (status != max22200::DriverStatus::OK) { printf(\"Initialization failed\\n\"); return; } // Configure channel max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 500; config.hold_current = 200; config.hit_time = 1000; status = driver.ConfigureChannel(0, config); if (status != max22200::DriverStatus::OK) { printf(\"Channel configuration failed\\n\"); return; } // Enable channel driver.EnableChannel(0, true); // Read current uint16_t current; if (driver.ReadCurrent(0, current) == max22200::DriverStatus::OK) { printf(\"Channel 0 current: %u mA\\n\", current); } } . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#complete-example-with-error-handling",
    
    "relUrl": "/docs/quickstart/#complete-example-with-error-handling"
  },"106": {
    "doc": "‚ö° Quick Start",
    "title": "Expected Output",
    "content": "When running this example, you should see: . | 1 . | Channel 0 current: 500 mA . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#expected-output",
    
    "relUrl": "/docs/quickstart/#expected-output"
  },"107": {
    "doc": "‚ö° Quick Start",
    "title": "Troubleshooting",
    "content": "If you encounter issues: . | Compilation errors: Check that you‚Äôve implemented the transfer() method in your SPI interface | Initialization fails: Verify SPI connections and hardware setup | Channel not working: Check channel configuration and enable state | See: Troubleshooting for common issues | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#troubleshooting",
    
    "relUrl": "/docs/quickstart/#troubleshooting"
  },"108": {
    "doc": "‚ö° Quick Start",
    "title": "Next Steps",
    "content": ". | Explore Examples for more advanced usage | Review the API Reference for all available methods | Check Configuration for customization options | . Navigation ‚¨ÖÔ∏è Installation | Next: Hardware Setup ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#next-steps",
    
    "relUrl": "/docs/quickstart/#next-steps"
  },"109": {
    "doc": "‚ö° Quick Start",
    "title": "‚ö° Quick Start",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/quickstart/",
    
    "relUrl": "/docs/quickstart/"
  },"110": {
    "doc": "üêõ Troubleshooting",
    "title": "Troubleshooting",
    "content": "This guide helps you diagnose and resolve common issues when using the MAX22200 driver. ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#troubleshooting",
    
    "relUrl": "/docs/troubleshooting/#troubleshooting"
  },"111": {
    "doc": "üêõ Troubleshooting",
    "title": "Common Error Messages",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#common-error-messages",
    
    "relUrl": "/docs/troubleshooting/#common-error-messages"
  },"112": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Initialization Failed",
    "content": "Symptoms: . | Initialize() returns INITIALIZATION_ERROR | Driver not responding | . Causes: . | SPI interface not properly initialized | Hardware connections incorrect | Power supply issues | . Solutions: . | Verify SPI Interface: Ensure SPI interface is initialized before creating driver | Check Connections: Verify all SPI connections (SCLK, SDI, SDO, CS) | Verify Power: Check power supply voltage (2.7V - 5.5V) | Check CS Line: Verify chip select is properly controlled | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#error-initialization-failed",
    
    "relUrl": "/docs/troubleshooting/#error-initialization-failed"
  },"113": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Communication Error",
    "content": "Symptoms: . | COMMUNICATION_ERROR returned from methods | No response from device | . Causes: . | SPI configuration incorrect | Signal integrity issues | CS timing problems | . Solutions: . | Check SPI Mode: Ensure SPI Mode 0 or Mode 3 | Verify Speed: Try lower SPI speed (e.g., 1 MHz) | Check CS Timing: Verify CS assertion/deassertion timing | Verify Connections: Check all SPI connections are secure | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#error-communication-error",
    
    "relUrl": "/docs/troubleshooting/#error-communication-error"
  },"114": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Channel Not Working",
    "content": "Symptoms: . | Channel enabled but no output | Current not flowing | . Causes: . | Channel not properly configured | Channel not enabled | Load not connected correctly | Fault condition | . Solutions: . | Check Configuration: Verify channel configuration is correct | Check Enable State: Ensure channel is enabled via EnableChannel() | Verify Load: Check load connections (OUTA/OUTB to load) | Check Faults: Read fault status to identify issues | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#error-channel-not-working",
    
    "relUrl": "/docs/troubleshooting/#error-channel-not-working"
  },"115": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Overcurrent Protection (OCP)",
    "content": "Symptoms: . | FaultStatus.overcurrent_protection is true | Channel disabled automatically | . Causes: . | Load current exceeds limits | Short circuit | Incorrect current settings | . Solutions: . | Check Load: Verify load is within specifications (1A RMS max per channel) | Reduce Current: Lower hit_current and hold_current settings | Check for Shorts: Verify no short circuits in wiring | Clear Fault: Read fault status to clear, then reconfigure | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#error-overcurrent-protection-ocp",
    
    "relUrl": "/docs/troubleshooting/#error-overcurrent-protection-ocp"
  },"116": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Open Load Detection",
    "content": "Symptoms: . | FaultStatus.open_load is true | No current flow | . Causes: . | Load not connected | Broken connection | Load impedance too high | . Solutions: . | Check Connections: Verify load is properly connected | Check Wiring: Inspect for broken wires | Verify Load: Ensure load impedance is appropriate | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#error-open-load-detection",
    
    "relUrl": "/docs/troubleshooting/#error-open-load-detection"
  },"117": {
    "doc": "üêõ Troubleshooting",
    "title": "Hardware Issues",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#hardware-issues",
    
    "relUrl": "/docs/troubleshooting/#hardware-issues"
  },"118": {
    "doc": "üêõ Troubleshooting",
    "title": "Device Not Responding",
    "content": "Checklist: . | Verify power supply voltage is 2.7V - 5.5V | Check all SPI connections are secure | Verify CS line is properly controlled | Check for short circuits | Use oscilloscope/logic analyzer to verify bus activity | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#device-not-responding",
    
    "relUrl": "/docs/troubleshooting/#device-not-responding"
  },"119": {
    "doc": "üêõ Troubleshooting",
    "title": "Incorrect Current Readings",
    "content": "Symptoms: . | Current readings don‚Äôt match expected values | ICS readings are zero or incorrect | . Causes: . | ICS not enabled | Channel not active | Incorrect configuration | . Solutions: . | Enable ICS: Call SetIntegratedCurrentSensing(true) | Check Channel State: Verify channel is enabled and active | Verify Configuration: Check current settings are correct | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#incorrect-current-readings",
    
    "relUrl": "/docs/troubleshooting/#incorrect-current-readings"
  },"120": {
    "doc": "üêõ Troubleshooting",
    "title": "Software Issues",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#software-issues",
    
    "relUrl": "/docs/troubleshooting/#software-issues"
  },"121": {
    "doc": "üêõ Troubleshooting",
    "title": "Compilation Errors",
    "content": "Error: ‚ÄúNo matching function‚Äù . Solution: . | Ensure you‚Äôve implemented all required SPI interface methods | Check method signatures match the interface definition | . Error: ‚ÄúUndefined reference‚Äù . Solution: . | Verify you‚Äôre linking the driver source file | Check include paths are correct | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#compilation-errors",
    
    "relUrl": "/docs/troubleshooting/#compilation-errors"
  },"122": {
    "doc": "üêõ Troubleshooting",
    "title": "Runtime Errors",
    "content": "Initialization Fails . Checklist: . | SPI bus interface is properly initialized | Hardware connections are correct | Configuration parameters are valid | Device is powered and ready | . Unexpected Behavior . Checklist: . | Verify configuration matches your use case | Check for timing issues | Review error handling code | Check fault status | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#runtime-errors",
    
    "relUrl": "/docs/troubleshooting/#runtime-errors"
  },"123": {
    "doc": "üêõ Troubleshooting",
    "title": "Debugging Tips",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#debugging-tips",
    
    "relUrl": "/docs/troubleshooting/#debugging-tips"
  },"124": {
    "doc": "üêõ Troubleshooting",
    "title": "Enable Diagnostics",
    "content": "| 1 . | max22200::MAX22200 driver(spi, true); // Enable diagnostics . | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#enable-diagnostics",
    
    "relUrl": "/docs/troubleshooting/#enable-diagnostics"
  },"125": {
    "doc": "üêõ Troubleshooting",
    "title": "Check Fault Status",
    "content": "| 1 2 3 4 5 6 . | max22200::FaultStatus faults; driver.ReadFaultStatus(faults); if (faults.hasFault()) { printf(\"Faults detected: %d\\n\", faults.getFaultCount()); } . | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#check-fault-status",
    
    "relUrl": "/docs/troubleshooting/#check-fault-status"
  },"126": {
    "doc": "üêõ Troubleshooting",
    "title": "Read Channel Status",
    "content": "| 1 2 3 4 5 . | max22200::ChannelStatus status; driver.ReadChannelStatus(0, status); printf(\"Channel 0: enabled=%d, fault=%d, current=%u\\n\", status.enabled, status.fault_active, status.current_reading); . | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#read-channel-status",
    
    "relUrl": "/docs/troubleshooting/#read-channel-status"
  },"127": {
    "doc": "üêõ Troubleshooting",
    "title": "Use Callbacks",
    "content": "Set up fault callbacks to get notified immediately when faults occur: . | 1 2 3 4 5 . | void fault_handler(uint8_t channel, max22200::FaultType fault_type, void *user_data) { printf(\"Fault on channel %d\\n\", channel); } driver.SetFaultCallback(fault_handler); . | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#use-callbacks",
    
    "relUrl": "/docs/troubleshooting/#use-callbacks"
  },"128": {
    "doc": "üêõ Troubleshooting",
    "title": "FAQ",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#faq",
    
    "relUrl": "/docs/troubleshooting/#faq"
  },"129": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What is the maximum current per channel?",
    "content": "A: Each channel can handle up to 1A RMS. The hit_current and hold_current settings use 10-bit values (0-1023) that map to the actual current range. ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#q-what-is-the-maximum-current-per-channel",
    
    "relUrl": "/docs/troubleshooting/#q-what-is-the-maximum-current-per-channel"
  },"130": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Can I use multiple channels simultaneously?",
    "content": "A: Yes, all 8 channels can be used simultaneously. Each channel is independent. ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#q-can-i-use-multiple-channels-simultaneously",
    
    "relUrl": "/docs/troubleshooting/#q-can-i-use-multiple-channels-simultaneously"
  },"131": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What‚Äôs the difference between CDR and VDR modes?",
    "content": "A: CDR (Current Drive Regulation) regulates current during both hit and hold phases. VDR (Voltage Drive Regulation) applies constant voltage during hit phase and regulates current during hold phase. ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#q-whats-the-difference-between-cdr-and-vdr-modes",
    
    "relUrl": "/docs/troubleshooting/#q-whats-the-difference-between-cdr-and-vdr-modes"
  },"132": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: How do I clear a fault?",
    "content": "A: Read the fault status register to clear latched faults. Some faults (like OCP) may require reconfiguring the channel. ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#q-how-do-i-clear-a-fault",
    
    "relUrl": "/docs/troubleshooting/#q-how-do-i-clear-a-fault"
  },"133": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What is Integrated Current Sensing (ICS)?",
    "content": "A: ICS allows reading the actual current flowing through each channel without external sense resistors. Enable it with SetIntegratedCurrentSensing(true). ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#q-what-is-integrated-current-sensing-ics",
    
    "relUrl": "/docs/troubleshooting/#q-what-is-integrated-current-sensing-ics"
  },"134": {
    "doc": "üêõ Troubleshooting",
    "title": "Getting More Help",
    "content": "If you‚Äôre still experiencing issues: . | Check the API Reference for method details | Review Examples for working code | Search existing issues on GitHub | Open a new issue with: . | Description of the problem | Steps to reproduce | Hardware setup details | Error messages/logs | . | . Navigation ‚¨ÖÔ∏è Examples | Back to Index . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#getting-more-help",
    
    "relUrl": "/docs/troubleshooting/#getting-more-help"
  },"135": {
    "doc": "üêõ Troubleshooting",
    "title": "üêõ Troubleshooting",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/",
    
    "relUrl": "/docs/troubleshooting/"
  },"136": {
    "doc": "API Reference",
    "title": "API Reference",
    "content": "# API Reference Complete reference documentation for all public methods and types in the MAX22200 driver. ## Source Code - **Main Header**: [`inc/max22200.hpp`](../inc/max22200.hpp) - **SPI Interface**: [`inc/max22200_spi_interface.hpp`](../inc/max22200_spi_interface.hpp) - **Types**: [`inc/max22200_types.hpp`](../inc/max22200_types.hpp) ## Core Class ### `MAX22200` Main driver class for interfacing with the MAX22200 octal solenoid and motor driver. **Template Parameter**: `SpiType` - Your SPI interface implementation (must inherit from `max22200::SpiInterface`) **Location**: [`inc/max22200.hpp#L64`](../inc/max22200.hpp#L64) **Constructor:** ```cpp explicit MAX22200(SpiType &spi_interface, bool enable_diagnostics = true); ``` **Location**: [`inc/max22200.hpp#L73`](../inc/max22200.hpp#L73) ## Methods ### Initialization | Method | Signature | Location |--------|-----------|----------| `Initialize()` | `DriverStatus Initialize()` | [`inc/max22200.hpp#L100`](../inc/max22200.hpp#L100) | `Deinitialize()` | `DriverStatus Deinitialize()` | [`inc/max22200.hpp#L110`](../inc/max22200.hpp#L110) | `Reset()` | `DriverStatus Reset()` | [`inc/max22200.hpp#L120`](../inc/max22200.hpp#L120) | ### Global Configuration | Method | Signature | Location |--------|-----------|----------| `ConfigureGlobal()` | `DriverStatus ConfigureGlobal(const GlobalConfig &config)` | [`inc/max22200.hpp#L130`](../inc/max22200.hpp#L130) | `GetGlobalConfig()` | `DriverStatus GetGlobalConfig(GlobalConfig &config) const` | [`inc/max22200.hpp#L138`](../inc/max22200.hpp#L138) | `SetSleepMode()` | `DriverStatus SetSleepMode(bool enable)` | [`inc/max22200.hpp#L146`](../inc/max22200.hpp#L146) | `SetDiagnosticMode()` | `DriverStatus SetDiagnosticMode(bool enable)` | [`inc/max22200.hpp#L154`](../inc/max22200.hpp#L154) | `SetIntegratedCurrentSensing()` | `DriverStatus SetIntegratedCurrentSensing(bool enable)` | [`inc/max22200.hpp#L162`](../inc/max22200.hpp#L162) | ### Channel Configuration | Method | Signature | Location |--------|-----------|----------| `ConfigureChannel()` | `DriverStatus ConfigureChannel(uint8_t channel, const ChannelConfig &config)` | [`inc/max22200.hpp#L173`](../inc/max22200.hpp#L173) | `GetChannelConfig()` | `DriverStatus GetChannelConfig(uint8_t channel, ChannelConfig &config) const` | [`inc/max22200.hpp#L182`](../inc/max22200.hpp#L182) | `ConfigureAllChannels()` | `DriverStatus ConfigureAllChannels(const ChannelConfigArray &configs)` | [`inc/max22200.hpp#L190`](../inc/max22200.hpp#L190) | `GetAllChannelConfigs()` | `DriverStatus GetAllChannelConfigs(ChannelConfigArray &configs) const` | [`inc/max22200.hpp#L198`](../inc/max22200.hpp#L198) | ### Channel Control | Method | Signature | Location |--------|-----------|----------| `EnableChannel()` | `DriverStatus EnableChannel(uint8_t channel, bool enable)` | [`inc/max22200.hpp#L209`](../inc/max22200.hpp#L209) | `EnableAllChannels()` | `DriverStatus EnableAllChannels(bool enable)` | [`inc/max22200.hpp#L217`](../inc/max22200.hpp#L217) | `SetChannelDriveMode()` | `DriverStatus SetChannelDriveMode(uint8_t channel, DriveMode mode)` | [`inc/max22200.hpp#L226`](../inc/max22200.hpp#L226) | `SetChannelBridgeMode()` | `DriverStatus SetChannelBridgeMode(uint8_t channel, BridgeMode mode)` | [`inc/max22200.hpp#L235`](../inc/max22200.hpp#L235) | `SetChannelPolarity()` | `DriverStatus SetChannelPolarity(uint8_t channel, OutputPolarity polarity)` | [`inc/max22200.hpp#L244`](../inc/max22200.hpp#L244) | ### Current Control | Method | Signature | Location |--------|-----------|----------| `SetHitCurrent()` | `DriverStatus SetHitCurrent(uint8_t channel, uint16_t current)` | [`inc/max22200.hpp#L255`](../inc/max22200.hpp#L255) | `SetHoldCurrent()` | `DriverStatus SetHoldCurrent(uint8_t channel, uint16_t current)` | [`inc/max22200.hpp#L264`](../inc/max22200.hpp#L264) | `SetCurrents()` | `DriverStatus SetCurrents(uint8_t channel, uint16_t hit_current, uint16_t hold_current)` | [`inc/max22200.hpp#L274`](../inc/max22200.hpp#L274) | `GetCurrents()` | `DriverStatus GetCurrents(uint8_t channel, uint16_t &hit_current, uint16_t &hold_current) const` | [`inc/max22200.hpp#L285`](../inc/max22200.hpp#L285) | ### Timing Control | Method | Signature | Location |--------|-----------|----------| `SetHitTime()` | `DriverStatus SetHitTime(uint8_t channel, uint16_t time)` | [`inc/max22200.hpp#L297`](../inc/max22200.hpp#L297) | `GetHitTime()` | `DriverStatus GetHitTime(uint8_t channel, uint16_t &time) const` | [`inc/max22200.hpp#L306`](../inc/max22200.hpp#L306) | ### Status and Diagnostics | Method | Signature | Location |--------|-----------|----------| `ReadFaultStatus()` | `DriverStatus ReadFaultStatus(FaultStatus &status) const` | [`inc/max22200.hpp#L316`](../inc/max22200.hpp#L316) | `ClearFaultStatus()` | `DriverStatus ClearFaultStatus()` | [`inc/max22200.hpp#L325`](../inc/max22200.hpp#L325) | `ReadChannelStatus()` | `DriverStatus ReadChannelStatus(uint8_t channel, ChannelStatus &status) const` | [`inc/max22200.hpp#L334`](../inc/max22200.hpp#L334) | `ReadAllChannelStatuses()` | `DriverStatus ReadAllChannelStatuses(ChannelStatusArray &statuses) const` | [`inc/max22200.hpp#L342`](../inc/max22200.hpp#L342) | `GetStatistics()` | `DriverStatus GetStatistics(DriverStatistics &stats) const` | [`inc/max22200.hpp#L350`](../inc/max22200.hpp#L350) | `ResetStatistics()` | `DriverStatus ResetStatistics()` | [`inc/max22200.hpp#L359`](../inc/max22200.hpp#L359) | ### Callbacks | Method | Signature | Location |--------|-----------|----------| `SetFaultCallback()` | `void SetFaultCallback(FaultCallback callback, void *user_data = nullptr)` | [`inc/max22200.hpp#L369`](../inc/max22200.hpp#L369) | `SetStateChangeCallback()` | `void SetStateChangeCallback(StateChangeCallback callback, void *user_data = nullptr)` | [`inc/max22200.hpp#L377`](../inc/max22200.hpp#L377) | ### Utility | Method | Signature | Location |--------|-----------|----------| `IsInitialized()` | `bool IsInitialized() const` | [`inc/max22200.hpp#L387`](../inc/max22200.hpp#L387) | `IsValidChannel()` | `static constexpr bool IsValidChannel(uint8_t channel)` | [`inc/max22200.hpp#L395`](../inc/max22200.hpp#L395) | `GetVersion()` | `static constexpr const char *GetVersion()` | [`inc/max22200.hpp#L404`](../inc/max22200.hpp#L404) | ## Types ### Enumerations | Type | Values | Location |------|--------|----------| `DriverStatus` | `OK`, `INITIALIZATION_ERROR`, `COMMUNICATION_ERROR`, `INVALID_PARAMETER`, `HARDWARE_FAULT`, `TIMEOUT` | [`inc/max22200_types.hpp#L201`](../inc/max22200_types.hpp#L201) | `DriveMode` | `CDR`, `VDR` | [`inc/max22200_types.hpp#L23`](../inc/max22200_types.hpp#L23) | `BridgeMode` | `HALF_BRIDGE`, `FULL_BRIDGE` | [`inc/max22200_types.hpp#L31`](../inc/max22200_types.hpp#L31) | `OutputPolarity` | `NORMAL`, `INVERTED` | [`inc/max22200_types.hpp#L39`](../inc/max22200_types.hpp#L39) | `FaultType` | `OCP`, `OL`, `DPM`, `UVLO`, `HHF`, `TSD` | [`inc/max22200_types.hpp#L47`](../inc/max22200_types.hpp#L47) | `ChannelState` | `DISABLED`, `ENABLED`, `HIT_PHASE`, `HOLD_PHASE`, `FAULT` | [`inc/max22200_types.hpp#L213`](../inc/max22200_types.hpp#L213) | ### Structures | Type | Description | Location |------|-------------|----------| `ChannelConfig` | Channel configuration structure | [`inc/max22200_types.hpp#L62`](../inc/max22200_types.hpp#L62) | `GlobalConfig` | Global configuration structure | [`inc/max22200_types.hpp#L106`](../inc/max22200_types.hpp#L106) | `FaultStatus` | Fault status structure | [`inc/max22200_types.hpp#L128`](../inc/max22200_types.hpp#L128) | `ChannelStatus` | Channel status structure | [`inc/max22200_types.hpp#L182`](../inc/max22200_types.hpp#L182) | `DriverStatistics` | Driver statistics structure | [`inc/max22200_types.hpp#L262`](../inc/max22200_types.hpp#L262) | ### Type Aliases | Type | Definition | Location |------|------------|----------| `ChannelConfigArray` | `std::array` | [`inc/max22200_types.hpp#L224`](../inc/max22200_types.hpp#L224) | `ChannelStatusArray` | `std::array` | [`inc/max22200_types.hpp#L229`](../inc/max22200_types.hpp#L229) | `FaultCallback` | `void (*)(uint8_t channel, FaultType fault_type, void *user_data)` | [`inc/max22200_types.hpp#L243`](../inc/max22200_types.hpp#L243) | `StateChangeCallback` | `void (*)(uint8_t channel, ChannelState old_state, ChannelState new_state, void *user_data)` | [`inc/max22200_types.hpp#L254`](../inc/max22200_types.hpp#L254) | --- **Navigation** ‚¨ÖÔ∏è [Configuration](/hf-max22200-driver/development/docs/configuration/) | [Next: Examples ‚û°Ô∏è](/hf-max22200-driver/development/docs/examples/) | [Back to Index](/hf-max22200-driver/development/docs/) ",
    "url": "/hf-max22200-driver/development/docs/api_reference.html",
    
    "relUrl": "/docs/api_reference.html"
  },"137": {
    "doc": "MAX22200 ESP32-C6 Comprehensive Test Suite",
    "title": "MAX22200 ESP32-C6 Comprehensive Test Suite",
    "content": "# MAX22200 ESP32-C6 Comprehensive Test Suite This directory contains comprehensive test suites for the MAX22200 octal solenoid and motor driver using the ESP32-C6 DevKit-M-1. ## üìã Table of Contents - [Hardware Overview](#-hardware-overview) - [Pin Connections](#-pin-connections) - [Hardware Setup](#-hardware-setup) - [Building the Tests](#-building-the-tests) - [Running the Tests](#-running-the-tests) - [Test Suites](#-test-suites) - [Troubleshooting](#-troubleshooting) --- ## üîå Hardware Overview ### ESP32-C6 DevKit-M-1 The ESP32-C6 DevKit-M-1 serves as the host controller for communicating with the MAX22200 driver via SPI. ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ESP32-C6 DevKit-M-1 ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ESP32-C6 Microcontroller ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ GPIO Pins: ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ SPI: MOSI (GPIO7), MISO (GPIO2), ‚îÇ ‚îÇ ‚îÇ ‚îÇ SCLK (GPIO6), CS (GPIO10) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Test Indicator: GPIO14 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ USB-C Connector ‚îÇ ‚îÇ (Power + Serial Communication) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` ### MAX22200 Octal Solenoid and Motor Driver The MAX22200 is an octal (eight-channel) solenoid and motor driver featuring: - **Eight Half-Bridges**: Each capable of handling up to 36V and 1A RMS - **Current and Voltage Regulation**: Supports both CDR and VDR modes - **Integrated Lossless Current Sensing (ICS)**: Real-time current monitoring - **High-Speed SPI Interface**: Up to 10MHz communication - **Comprehensive Protection**: OCP, OL, DPM, UVLO, TSD, and fault registers ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ MAX22200 Octal Driver ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ MAX22200 IC ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ Features: ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ 8 half-bridge channels (OUT0-OUT7) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ SPI interface (up to 10MHz) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Current regulation (CDR mode) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Voltage regulation (VDR mode) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Integrated current sensing (ICS) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Fault detection and reporting ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Thermal shutdown protection ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ SPI Connections: ‚îÇ ‚îÇ ‚Ä¢ MOSI (Master Out Slave In) ‚îÇ ‚îÇ ‚Ä¢ MISO (Master In Slave Out) ‚îÇ ‚îÇ ‚Ä¢ SCLK (Serial Clock) ‚îÇ ‚îÇ ‚Ä¢ CS (Chip Select) ‚îÇ ‚îÇ ‚îÇ ‚îÇ Power Connections: ‚îÇ ‚îÇ ‚Ä¢ VCC (3.3V/5V Logic Power) ‚îÇ ‚îÇ ‚Ä¢ VDD (12V-36V Load Power) ‚îÇ ‚îÇ ‚Ä¢ GND (Ground) ‚îÇ ‚îÇ ‚îÇ ‚îÇ Control Pins: ‚îÇ ‚îÇ ‚Ä¢ RESET (Reset Input) ‚îÇ ‚îÇ ‚Ä¢ FAULT (Fault Status Output) ‚îÇ ‚îÇ ‚Ä¢ DIAG (Diagnostic Output) ‚îÇ ‚îÇ ‚Ä¢ SHDN (Shutdown Input) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` --- ## üìå Pin Connections ### SPI Bus Connections | MAX22200 Pin | ESP32-C6 GPIO | Function | Notes |--------------|---------------|----------|-------| MOSI | GPIO7 | SPI Data Out | Master to Slave | MISO | GPIO2 | SPI Data In | Slave to Master | SCLK | GPIO6 | SPI Clock | Clock signal | CS | GPIO10 | Chip Select | Active low | VCC | 3.3V | Logic Power | 3.3V or 5V | VDD | 12V-36V | Load Power | For solenoids/motors | GND | GND | Ground | Common ground | RESET | GPIO5 (optional) | Reset Input | Active low | FAULT | GPIO4 (optional) | Fault Status | Open-drain, requires pull-up | DIAG | GPIO3 (optional) | Diagnostic | Open-drain, requires pull-up | SHDN | GPIO1 (optional) | Shutdown | Active low | ### Test Indicator | Signal | ESP32-C6 GPIO | Function |--------|---------------|----------| Test Progress | GPIO14 | Visual test progression indicator | ### SPI Configuration Default SPI configuration (can be modified in test file): - **Mode**: Mode 0 (CPOL=0, CPHA=0) or Mode 3 (CPOL=1, CPHA=1) - **Bit Order**: MSB first - **Clock Speed**: Up to 10MHz (5MHz with daisy chaining) - **Data Width**: 8-bit transfers - **Chip Select**: Active low, controlled by software --- ## üõ†Ô∏è Hardware Setup ### Basic Setup 1. **Connect SPI Bus**: - Connect MAX22200 MOSI to ESP32-C6 GPIO7 - Connect MAX22200 MISO to ESP32-C6 GPIO2 - Connect MAX22200 SCLK to ESP32-C6 GPIO6 - Connect MAX22200 CS to ESP32-C6 GPIO10 2. **Power Connections**: - Connect MAX22200 VCC to ESP32-C6 3.3V (logic power) - Connect MAX22200 VDD to 12V-36V power supply (load power) - Connect MAX22200 GND to ESP32-C6 GND (common ground) 3. **Optional Control Pins**: - Connect MAX22200 RESET to ESP32-C6 GPIO5 (optional, can use software reset) - Connect MAX22200 FAULT to ESP32-C6 GPIO4 (optional, for fault monitoring) - Connect MAX22200 DIAG to ESP32-C6 GPIO3 (optional, for diagnostics) - Connect MAX22200 SHDN to ESP32-C6 GPIO1 (optional, for hardware shutdown) 4. **Load Connections**: - Connect solenoids or motors to OUT0-OUT7 pins - Ensure proper current ratings (max 1A RMS per channel) - Use appropriate flyback diodes for inductive loads ### Test Setup For comprehensive testing, you can connect: - Solenoids or motors to output channels (with appropriate current ratings) - Current measurement equipment for ICS verification - Logic analyzer on SPI bus for protocol verification - Oscilloscope for timing analysis --- ## üöÄ Building the Tests ### Prerequisites 1. **Install ESP-IDF** (if not already installed): ```bash # Clone ESP-IDF git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf # Checkout release version 5.5 git checkout release/v5.5 git submodule update --init --recursive # Install ESP-IDF (Linux/macOS) ./install.sh esp32c6 # Set up environment (add to ~/.bashrc or ~/.zshrc for persistence) ./export.sh ``` 2. **Navigate to ESP32 Examples**: ```bash cd examples/esp32 ``` 3. **Setup Repository** (First time only): ```bash # Make scripts executable and setup the build environment chmod +x scripts/*.sh ./scripts/setup_repo.sh ``` ### Available Test Applications The test suites use a centralized build system with scripts. Available applications: | **Application Name** | **Description** | **Hardware Required** |----------------------|----------------|----------------------| `max22200_comprehensive_test` | Comprehensive MAX22200 driver testing with all features | MAX22200 board | ### List Available Applications ```bash # List all available applications ./scripts/build_app.sh list ``` ### Build an Application ```bash # Build comprehensive test (Debug build) ./scripts/build_app.sh max22200_comprehensive_test Debug # Build comprehensive test (Release build) ./scripts/build_app.sh max22200_comprehensive_test Release ``` --- ## üì§ Running the Tests ### Flash Application ```bash # Flash the application to ESP32-C6 ./scripts/flash_app.sh max22200_comprehensive_test Debug # Or manually: idf.py -p /dev/ttyUSB0 flash ``` ### Monitor Output ```bash # Monitor serial output idf.py -p /dev/ttyUSB0 monitor # Or use the flash script which includes monitoring ./scripts/flash_app.sh max22200_comprehensive_test Debug ``` ### Auto-detect Port ```bash # The scripts can auto-detect the port ./scripts/detect_ports.sh ``` --- ## üß™ Test Suites ### Comprehensive Test Suite **Application**: `max22200_comprehensive_test` This comprehensive test suite validates all MAX22200 functionality: #### Test Sections 1. **Initialization Tests** - SPI bus initialization - Driver initialization - Reset to default state - Global configuration 2. **Channel Configuration Tests** - Single channel configuration - Multiple channel configuration - All channels configuration - Channel enable/disable 3. **Current Control Tests** - Hit current setting - Hold current setting - Current reading (ICS) - Current regulation (CDR mode) 4. **Voltage Control Tests** - Voltage regulation (VDR mode) - Voltage setting and reading 5. **Drive Mode Tests** - CDR (Current Drive Regulation) mode - VDR (Voltage Drive Regulation) mode - Bridge mode configuration 6. **Fault Detection Tests** - Overcurrent protection (OCP) - Overload (OL) detection - Dynamic power management (DPM) - Thermal shutdown (TSD) - Under-voltage lockout (UVLO) 7. **Diagnostic Tests** - Diagnostic mode enable/disable - Fault status reading - Fault callback registration 8. **Statistics Tests** - Operation statistics tracking - Error counting - Performance metrics 9. **Error Handling Tests** - Invalid channel handling - Error flag management - Error recovery 10. **Stress Tests** - Rapid channel operations - Continuous read/write cycles - Multi-channel simultaneous operations #### Test Configuration You can enable/disable specific test sections by editing the test file: ```cpp // In MAX22200ComprehensiveTest.cpp static constexpr bool ENABLE_BASIC_TESTS = true; // ... etc ``` #### Test Results The test framework provides: - Automatic pass/fail tracking - Execution time measurement - GPIO14 progress indicator (toggles on each test) - Comprehensive test summary - Success percentage calculation --- ## üîß Configuration ### SPI Bus Configuration Default SPI configuration (can be modified in test file): ```cpp // SPI configuration for MAX22200 // Mode: 0 (CPOL=0, CPHA=0) or 3 (CPOL=1, CPHA=1) // Speed: Up to 10MHz // Bit Order: MSB first ``` ### MAX22200 Configuration Default MAX22200 settings (can be modified in test file): ```cpp // Global configuration GlobalConfig global_config; global_config.diagnostic_enable = true; global_config.ics_enable = true; global_config.daisy_chain_mode = false; global_config.sleep_mode = false; // Channel configuration ChannelConfig channel_config; channel_config.enabled = true; channel_config.drive_mode = DriveMode::CDR; channel_config.hit_current = 500; // mA channel_config.hold_current = 200; // mA ``` --- ## üêõ Troubleshooting ### SPI Communication Failures **Symptoms**: Tests fail with SPI errors **Solutions**: 1. **Check SPI connections**: - Verify MOSI/MISO/SCLK/CS connections - Ensure proper power connections - Check for loose connections 2. **Verify SPI configuration**: - Check SPI mode (0 or 3) - Verify clock speed (reduce if using long wires) - Ensure CS is properly controlled 3. **Verify power supply**: - Ensure 3.3V logic power is stable - Check 12V-36V load power is present - Check for voltage drops ### Build Errors **Symptoms**: CMake or compilation errors **Solutions**: 1. **Verify ESP-IDF version**: ```bash idf.py --version # Should show ESP-IDF v5.5 or compatible ``` 2. **Clean and rebuild**: ```bash idf.py fullclean ./scripts/build_app.sh max22200_comprehensive_test Debug ``` 3. **Check component paths**: - Verify component CMakeLists.txt paths - Ensure source files are accessible ### Test Failures **Symptoms**: Specific tests fail **Solutions**: 1. **Check hardware connections**: - Verify all pins are properly connected - Check for loose connections - Verify load connections (solenoids/motors) 2. **Review test logs**: - Check which specific test failed - Review error messages in serial output 3. **Verify device state**: - Reset MAX22200 (power cycle or software reset) - Run reset test first 4. **Check current/voltage settings**: - Verify current settings are within limits (max 1A RMS) - Check voltage supply is within range (12V-36V) --- ## üìö Additional Resources - [MAX22200 Datasheet](/hf-max22200-driver/development/datasheet/MAX22200.pdf) - [Driver API Documentation](/hf-max22200-driver/development/docs/api_reference.html) - [Hardware Integration Guide](../../docs/hardware_guide.md) - [ASCII Diagrams](../../docs/ascii_diagrams.md) --- ## üéØ Quick Reference ### Build Commands ```bash # List available apps ./scripts/build_app.sh list # Build comprehensive test ./scripts/build_app.sh max22200_comprehensive_test Debug # Flash and monitor ./scripts/flash_app.sh max22200_comprehensive_test Debug ``` ### Test Execution The comprehensive test suite runs automatically on boot and provides: - Real-time test progress via GPIO14 indicator - Serial output with detailed test results - Automatic test summary at completion ### GPIO14 Test Indicator GPIO14 toggles between HIGH/LOW for each completed test, providing visual feedback: - Use oscilloscope or logic analyzer to monitor - Useful for automated test verification - Blinks 5 times at section start/end --- ## üìù Notes - **SPI Configuration**: Use Mode 0 or Mode 3, MSB first, up to 10MHz clock - **Power Requirements**: 3.3V/5V for logic, 12V-36V for load power - **Current Limits**: Maximum 1A RMS per channel - **Test Duration**: Comprehensive test suite takes approximately 2-5 minutes to complete - **Hardware Requirements**: Basic tests work without external hardware; some tests require solenoids/motors connected --- üéØ Ready to test the MAX22200? Start with: ./scripts/build_app.sh max22200_comprehensive_test Debug ",
    "url": "/hf-max22200-driver/development/examples/esp32/",
    
    "relUrl": "/examples/esp32/"
  }
}
