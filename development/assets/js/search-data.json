{"0": {
    "doc": "API Reference",
    "title": "API Reference",
    "content": "# API Reference Complete reference documentation for all public methods and types in the MAX22200 driver. ## Source Code - **Main Header**: [`inc/max22200.hpp`](../inc/max22200.hpp) - **SPI Interface**: [`inc/max22200_spi_interface.hpp`](../inc/max22200_spi_interface.hpp) - **Types**: [`inc/max22200_types.hpp`](../inc/max22200_types.hpp) - **Implementation**: [`src/max22200.cpp`](../src/max22200.cpp) ## Core Class ### `MAX22200` Main driver class for interfacing with the MAX22200 octal solenoid and motor driver. **Template Parameter**: `SpiType` - Your SPI interface implementation (must inherit from `max22200::SpiInterface`) **Location**: [`inc/max22200.hpp#L64`](../inc/max22200.hpp#L64) **Constructor:** ```cpp explicit MAX22200(SpiType &spi_interface, bool enable_diagnostics = true); ``` **Location**: [`inc/max22200.hpp#L73`](../inc/max22200.hpp#L73) ## Methods ### Initialization | Method | Signature | Location |--------|-----------|----------| `Initialize()` | `DriverStatus Initialize()` | [`inc/max22200.hpp#L100`](../inc/max22200.hpp#L100) | `Deinitialize()` | `DriverStatus Deinitialize()` | [`inc/max22200.hpp#L110`](../inc/max22200.hpp#L110) | `Reset()` | `DriverStatus Reset()` | [`inc/max22200.hpp#L120`](../inc/max22200.hpp#L120) | ### Global Configuration | Method | Signature | Location |--------|-----------|----------| `ConfigureGlobal()` | `DriverStatus ConfigureGlobal(const GlobalConfig &config)` | [`inc/max22200.hpp#L130`](../inc/max22200.hpp#L130) | `GetGlobalConfig()` | `DriverStatus GetGlobalConfig(GlobalConfig &config) const` | [`inc/max22200.hpp#L138`](../inc/max22200.hpp#L138) | `SetSleepMode()` | `DriverStatus SetSleepMode(bool enable)` | [`inc/max22200.hpp#L146`](../inc/max22200.hpp#L146) | `SetDiagnosticMode()` | `DriverStatus SetDiagnosticMode(bool enable)` | [`inc/max22200.hpp#L154`](../inc/max22200.hpp#L154) | `SetIntegratedCurrentSensing()` | `DriverStatus SetIntegratedCurrentSensing(bool enable)` | [`inc/max22200.hpp#L162`](../inc/max22200.hpp#L162) | ### Channel Configuration | Method | Signature | Location |--------|-----------|----------| `ConfigureChannel()` | `DriverStatus ConfigureChannel(uint8_t channel, const ChannelConfig &config)` | [`inc/max22200.hpp#L173`](../inc/max22200.hpp#L173) | `GetChannelConfig()` | `DriverStatus GetChannelConfig(uint8_t channel, ChannelConfig &config) const` | [`inc/max22200.hpp#L182`](../inc/max22200.hpp#L182) | `ConfigureAllChannels()` | `DriverStatus ConfigureAllChannels(const ChannelConfigArray &configs)` | [`inc/max22200.hpp#L190`](../inc/max22200.hpp#L190) | `GetAllChannelConfigs()` | `DriverStatus GetAllChannelConfigs(ChannelConfigArray &configs) const` | [`inc/max22200.hpp#L198`](../inc/max22200.hpp#L198) | ### Channel Control | Method | Signature | Location |--------|-----------|----------| `EnableChannel()` | `DriverStatus EnableChannel(uint8_t channel, bool enable)` | [`inc/max22200.hpp#L209`](../inc/max22200.hpp#L209) | `EnableAllChannels()` | `DriverStatus EnableAllChannels(bool enable)` | [`inc/max22200.hpp#L217`](../inc/max22200.hpp#L217) | `SetChannelDriveMode()` | `DriverStatus SetChannelDriveMode(uint8_t channel, DriveMode mode)` | [`inc/max22200.hpp#L226`](../inc/max22200.hpp#L226) | `SetChannelBridgeMode()` | `DriverStatus SetChannelBridgeMode(uint8_t channel, BridgeMode mode)` | [`inc/max22200.hpp#L235`](../inc/max22200.hpp#L235) | `SetChannelPolarity()` | `DriverStatus SetChannelPolarity(uint8_t channel, OutputPolarity polarity)` | [`inc/max22200.hpp#L244`](../inc/max22200.hpp#L244) | ### Current Control | Method | Signature | Location |--------|-----------|----------| `SetHitCurrent()` | `DriverStatus SetHitCurrent(uint8_t channel, uint16_t current)` | [`inc/max22200.hpp#L255`](../inc/max22200.hpp#L255) | `SetHoldCurrent()` | `DriverStatus SetHoldCurrent(uint8_t channel, uint16_t current)` | [`inc/max22200.hpp#L264`](../inc/max22200.hpp#L264) | `SetCurrents()` | `DriverStatus SetCurrents(uint8_t channel, uint16_t hit_current, uint16_t hold_current)` | [`inc/max22200.hpp#L274`](../inc/max22200.hpp#L274) | `GetCurrents()` | `DriverStatus GetCurrents(uint8_t channel, uint16_t &hit_current, uint16_t &hold_current) const` | [`inc/max22200.hpp#L285`](../inc/max22200.hpp#L285) | ### Timing Control | Method | Signature | Location |--------|-----------|----------| `SetHitTime()` | `DriverStatus SetHitTime(uint8_t channel, uint16_t time)` | [`inc/max22200.hpp#L297`](../inc/max22200.hpp#L297) | `GetHitTime()` | `DriverStatus GetHitTime(uint8_t channel, uint16_t &time) const` | [`inc/max22200.hpp#L306`](../inc/max22200.hpp#L306) | ### Status and Diagnostics | Method | Signature | Location |--------|-----------|----------| `ReadFaultStatus()` | `DriverStatus ReadFaultStatus(FaultStatus &status) const` | [`inc/max22200.hpp#L316`](../inc/max22200.hpp#L316) | `ClearFaultStatus()` | `DriverStatus ClearFaultStatus()` | [`inc/max22200.hpp#L325`](../inc/max22200.hpp#L325) | `ReadChannelStatus()` | `DriverStatus ReadChannelStatus(uint8_t channel, ChannelStatus &status) const` | [`inc/max22200.hpp#L334`](../inc/max22200.hpp#L334) | `ReadAllChannelStatuses()` | `DriverStatus ReadAllChannelStatuses(ChannelStatusArray &statuses) const` | [`inc/max22200.hpp#L342`](../inc/max22200.hpp#L342) | `GetStatistics()` | `DriverStatus GetStatistics(DriverStatistics &stats) const` | [`inc/max22200.hpp#L350`](../inc/max22200.hpp#L350) | `ResetStatistics()` | `DriverStatus ResetStatistics()` | [`inc/max22200.hpp#L359`](../inc/max22200.hpp#L359) | ### Callbacks | Method | Signature | Location |--------|-----------|----------| `SetFaultCallback()` | `void SetFaultCallback(FaultCallback callback, void *user_data = nullptr)` | [`inc/max22200.hpp#L369`](../inc/max22200.hpp#L369) | `SetStateChangeCallback()` | `void SetStateChangeCallback(StateChangeCallback callback, void *user_data = nullptr)` | [`inc/max22200.hpp#L377`](../inc/max22200.hpp#L377) | ### Utility | Method | Signature | Location |--------|-----------|----------| `IsInitialized()` | `bool IsInitialized() const` | [`inc/max22200.hpp#L387`](../inc/max22200.hpp#L387) | `IsValidChannel()` | `static constexpr bool IsValidChannel(uint8_t channel)` | [`inc/max22200.hpp#L395`](../inc/max22200.hpp#L395) | `GetVersion()` | `static constexpr const char *GetVersion()` | [`inc/max22200.hpp#L404`](../inc/max22200.hpp#L404) | ## Types ### Enumerations | Type | Values | Location |------|--------|----------| `DriverStatus` | `OK`, `INITIALIZATION_ERROR`, `COMMUNICATION_ERROR`, `INVALID_PARAMETER`, `HARDWARE_FAULT`, `TIMEOUT` | [`inc/max22200_types.hpp#L201`](../inc/max22200_types.hpp#L201) | `DriveMode` | `CDR`, `VDR` | [`inc/max22200_types.hpp#L23`](../inc/max22200_types.hpp#L23) | `BridgeMode` | `HALF_BRIDGE`, `FULL_BRIDGE` | [`inc/max22200_types.hpp#L31`](../inc/max22200_types.hpp#L31) | `OutputPolarity` | `NORMAL`, `INVERTED` | [`inc/max22200_types.hpp#L39`](../inc/max22200_types.hpp#L39) | `FaultType` | `OCP`, `OL`, `DPM`, `UVLO`, `HHF`, `TSD` | [`inc/max22200_types.hpp#L47`](../inc/max22200_types.hpp#L47) | `ChannelState` | `DISABLED`, `ENABLED`, `HIT_PHASE`, `HOLD_PHASE`, `FAULT` | [`inc/max22200_types.hpp#L213`](../inc/max22200_types.hpp#L213) | ### Structures | Type | Description | Location |------|-------------|----------| `ChannelConfig` | Channel configuration structure | [`inc/max22200_types.hpp#L62`](../inc/max22200_types.hpp#L62) | `GlobalConfig` | Global configuration structure | [`inc/max22200_types.hpp#L106`](../inc/max22200_types.hpp#L106) | `FaultStatus` | Fault status structure | [`inc/max22200_types.hpp#L128`](../inc/max22200_types.hpp#L128) | `ChannelStatus` | Channel status structure | [`inc/max22200_types.hpp#L182`](../inc/max22200_types.hpp#L182) | `DriverStatistics` | Driver statistics structure | [`inc/max22200_types.hpp#L262`](../inc/max22200_types.hpp#L262) | ### Type Aliases | Type | Definition | Location |------|------------|----------| `ChannelConfigArray` | `std::array` | [`inc/max22200_types.hpp#L224`](../inc/max22200_types.hpp#L224) | `ChannelStatusArray` | `std::array` | [`inc/max22200_types.hpp#L229`](../inc/max22200_types.hpp#L229) | `FaultCallback` | `void (*)(uint8_t channel, FaultType fault_type, void *user_data)` | [`inc/max22200_types.hpp#L243`](../inc/max22200_types.hpp#L243) | `StateChangeCallback` | `void (*)(uint8_t channel, ChannelState old_state, ChannelState new_state, void *user_data)` | [`inc/max22200_types.hpp#L254`](../inc/max22200_types.hpp#L254) | --- **Navigation** ‚¨ÖÔ∏è [Configuration](/hf-max22200-driver/development/docs/configuration.html) | [Next: Examples ‚û°Ô∏è](/hf-max22200-driver/development/docs/examples.html) | [Back to Index](/hf-max22200-driver/development/docs/) ",
    "url": "/hf-max22200-driver/development/docs/API_Reference.html",
    
    "relUrl": "/docs/API_Reference.html"
  },"1": {
    "doc": "Configuration",
    "title": "Configuration",
    "content": "# Configuration This guide covers all configuration options available for the MAX22200 driver. ## Channel Configuration ### Basic Channel Setup ```cpp max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; // Current Drive Regulation config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.parallel_mode = false; config.polarity = max22200::OutputPolarity::NORMAL; config.hit_current = 500; // Hit current (0-1023) config.hold_current = 200; // Hold current (0-1023) config.hit_time = 1000; // Hit time in ms (0-65535) driver.ConfigureChannel(0, config); ``` ### Drive Modes #### CDR (Current Drive Regulation) ```cpp config.drive_mode = max22200::DriveMode::CDR; ``` - Regulates current to hit_current during hit phase - Regulates current to hold_current during hold phase - Best for solenoids and motors requiring constant current #### VDR (Voltage Drive Regulation) ```cpp config.drive_mode = max22200::DriveMode::VDR; ``` - Applies constant voltage during hit phase - Regulates current to hold_current during hold phase - Best for applications requiring fast response ### Bridge Modes #### Half-Bridge Mode ```cpp config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; ``` - Load connected between OUTA and GND - OUTB not used - Single-ended drive #### Full-Bridge Mode ```cpp config.bridge_mode = max22200::BridgeMode::FULL_BRIDGE; ``` - Load connected between OUTA and OUTB - Bidirectional drive - Can reverse current direction ### Current Settings ```cpp // Set hit and hold currents separately driver.SetHitCurrent(0, 500); // Channel 0, 500 mA driver.SetHoldCurrent(0, 200); // Channel 0, 200 mA // Or set both at once driver.SetCurrents(0, 500, 200); // Channel 0, hit=500mA, hold=200mA ``` **Current Range**: 0-1023 (10-bit resolution) ### Hit Time ```cpp driver.SetHitTime(0, 1000); // Channel 0, 1000 ms ``` **Time Range**: 0-65535 ms ## Global Configuration ### Global Settings ```cpp max22200::GlobalConfig global_config; global_config.reset = false; global_config.sleep_mode = false; global_config.diagnostic_enable = true; global_config.ics_enable = true; // Integrated Current Sensing global_config.daisy_chain_mode = false; driver.ConfigureGlobal(global_config); ``` ### Sleep Mode ```cpp driver.SetSleepMode(true); // Enable sleep mode driver.SetSleepMode(false); // Disable sleep mode ``` ### Diagnostic Mode ```cpp driver.SetDiagnosticMode(true); // Enable diagnostics ``` ### Integrated Current Sensing (ICS) ```cpp driver.SetIntegratedCurrentSensing(true); // Enable ICS ``` ## Channel Control ### Enable/Disable Channels ```cpp // Enable single channel driver.EnableChannel(0, true); // Disable single channel driver.EnableChannel(0, false); // Enable all channels driver.EnableAllChannels(true); // Disable all channels driver.EnableAllChannels(false); ``` ### Individual Channel Settings ```cpp // Set drive mode driver.SetChannelDriveMode(0, max22200::DriveMode::CDR); // Set bridge mode driver.SetChannelBridgeMode(0, max22200::BridgeMode::FULL_BRIDGE); // Set polarity driver.SetChannelPolarity(0, max22200::OutputPolarity::INVERTED); ``` ## Recommended Settings ### For Solenoid Control ```cpp max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 800; // High current for pull-in config.hold_current = 200; // Lower current for holding config.hit_time = 50; // Short hit time ``` ### For Motor Control ```cpp max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::FULL_BRIDGE; config.hit_current = 500; config.hold_current = 500; config.hit_time = 0; // Continuous operation ``` ### For Low-Power Applications ```cpp max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::VDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 300; config.hold_current = 100; config.hit_time = 100; ``` ## Next Steps - See [Examples](/hf-max22200-driver/development/docs/examples.html) for configuration examples - Review [API Reference](api_reference.md) for all configuration methods --- **Navigation** ‚¨ÖÔ∏è [Platform Integration](/hf-max22200-driver/development/docs/platform_integration.html) | [Next: API Reference ‚û°Ô∏è](api_reference.md) | [Back to Index](/hf-max22200-driver/development/docs/) ",
    "url": "/hf-max22200-driver/development/docs/configuration.html",
    
    "relUrl": "/docs/configuration.html"
  },"2": {
    "doc": "Examples",
    "title": "Examples",
    "content": "# Examples This guide provides complete, working examples demonstrating various use cases for the MAX22200 driver. ## Example 1: Basic Solenoid Control This example shows basic solenoid control with hit and hold currents. ```cpp #include \"max22200.hpp\" #include \"esp32_max22200_spi.hpp\" void app_main() { // 1. Configure SPI Esp32Max22200Spi::SPIConfig spi_config; spi_config.host = SPI2_HOST; spi_config.miso_pin = GPIO_NUM_2; spi_config.mosi_pin = GPIO_NUM_7; spi_config.sclk_pin = GPIO_NUM_6; spi_config.cs_pin = GPIO_NUM_10; spi_config.frequency = 10000000; spi_config.mode = 0; Esp32Max22200Spi spi(spi_config); spi.Initialize(); // 2. Create driver max22200::MAX22200 driver(spi); // 3. Initialize if (driver.Initialize() != max22200::DriverStatus::OK) { printf(\"Initialization failed\\n\"); return; } // 4. Configure channel 0 for solenoid max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 800; // 800 mA hit current config.hold_current = 200; // 200 mA hold current config.hit_time = 50; // 50 ms hit time driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); printf(\"Solenoid enabled\\n\"); } ``` --- ## Example 2: Motor Control with Full-Bridge This example demonstrates motor control using full-bridge mode. ```cpp #include \"max22200.hpp\" void app_main() { // ... SPI setup (same as Example 1) max22200::MAX22200 driver(spi); driver.Initialize(); // Configure channel 0 for motor max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::FULL_BRIDGE; config.hit_current = 500; config.hold_current = 500; config.hit_time = 0; // Continuous operation driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); // Read current uint16_t current; if (driver.ReadCurrent(0, current) == max22200::DriverStatus::OK) { printf(\"Motor current: %u mA\\n\", current); } } ``` --- ## Example 3: Fault Handling with Callbacks This example shows how to handle faults using callbacks. ```cpp #include \"max22200.hpp\" void fault_handler(uint8_t channel, max22200::FaultType fault_type, void *user_data) { const char* fault_names[] = { \"OCP\", \"OL\", \"DPM\", \"UVLO\", \"HHF\", \"TSD\" }; printf(\"Fault on channel %d: %s\\n\", channel, fault_names[static_cast(fault_type)]); } void app_main() { // ... SPI setup max22200::MAX22200 driver(spi); driver.Initialize(); // Set fault callback driver.SetFaultCallback(fault_handler); // Configure and enable channel max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.hit_current = 500; config.hold_current = 200; driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); // Monitor for faults while (true) { max22200::FaultStatus faults; driver.ReadFaultStatus(faults); if (faults.hasFault()) { printf(\"Fault detected: %d faults\\n\", faults.getFaultCount()); } vTaskDelay(pdMS_TO_TICKS(100)); } } ``` --- ## Example 4: Multiple Channels This example demonstrates controlling multiple channels. ```cpp #include \"max22200.hpp\" void app_main() { // ... SPI setup max22200::MAX22200 driver(spi); driver.Initialize(); // Configure multiple channels for (uint8_t ch = 0; ch < 8; ch++) { max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 500; config.hold_current = 200; config.hit_time = 100; driver.ConfigureChannel(ch, config); } // Enable all channels driver.EnableAllChannels(true); // Read status of all channels max22200::ChannelStatusArray statuses; driver.ReadAllChannelStatuses(statuses); for (uint8_t ch = 0; ch < 8; ch++) { printf(\"Channel %d: enabled=%d, current=%u\\n\", ch, statuses[ch].enabled, statuses[ch].current_reading); } } ``` --- ## Example 5: Current Monitoring This example demonstrates continuous current monitoring. ```cpp #include \"max22200.hpp\" void app_main() { // ... SPI setup max22200::MAX22200 driver(spi); driver.Initialize(); // Enable ICS driver.SetIntegratedCurrentSensing(true); // Configure channel max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.hit_current = 500; config.hold_current = 200; driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); // Monitor current while (true) { uint16_t current; if (driver.ReadCurrent(0, current) == max22200::DriverStatus::OK) { printf(\"Current: %u mA\\n\", current); } vTaskDelay(pdMS_TO_TICKS(100)); } } ``` --- ## Running the Examples ### ESP32 ```bash cd examples/esp32 idf.py build flash monitor ``` ### Other Platforms For other platforms, implement the SPI interface and compile with C++20 support. ## Next Steps - Review the [API Reference](api_reference.md) for method details - Check [Troubleshooting](/hf-max22200-driver/development/docs/troubleshooting.html) if you encounter issues - Explore the [examples directory](../examples/) for more examples --- **Navigation** ‚¨ÖÔ∏è [API Reference](api_reference.md) | [Next: Troubleshooting ‚û°Ô∏è](/hf-max22200-driver/development/docs/troubleshooting.html) | [Back to Index](/hf-max22200-driver/development/docs/) ",
    "url": "/hf-max22200-driver/development/docs/examples.html",
    
    "relUrl": "/docs/examples.html"
  },"3": {
    "doc": "Hardware Setup",
    "title": "Hardware Setup",
    "content": "# Hardware Setup This guide covers the physical connections and hardware requirements for the MAX22200 octal solenoid and motor driver chip. ## Pin Connections ### Basic SPI Connections ```text MCU MAX22200 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VDD GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GND SCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SCLK MOSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDI MISO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDO CS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CS ``` ### Pin Descriptions | Pin | Name | Description | Required |-----|------|-------------|----------| VDD | Power | 3.3V power supply (2.7V - 5.5V) | Yes | GND | Ground | Ground reference | Yes | SCLK | Clock | SPI clock line | Yes | SDI | Data In | SPI data input (from MCU) | Yes | SDO | Data Out | SPI data output (to MCU) | Yes | CS | Chip Select | SPI chip select (active low) | Yes | FAULT | Fault | Fault interrupt output (optional) | No | RESET | Reset | Reset input (optional) | No | ### Channel Output Pins Each of the 8 channels has two output pins: | Channel | OUTA | OUTB |---------|------|------| 0 | OUT0A | OUT0B | 1 | OUT1A | OUT1B | 2 | OUT2A | OUT2B | 3 | OUT3A | OUT3B | 4 | OUT4A | OUT4B | 5 | OUT5A | OUT5B | 6 | OUT6A | OUT6B | 7 | OUT7A | OUT7B | ## Power Requirements - **Supply Voltage**: 2.7V - 5.5V (3.3V or 5V typical) - **Current Consumption**: Depends on load, up to 1A RMS per channel - **Power Supply**: Clean supply with decoupling capacitors (100nF ceramic + 10¬µF tantalum recommended per channel) ## SPI Configuration - **Mode**: SPI Mode 0 (CPOL=0, CPHA=0) or Mode 3 (CPOL=1, CPHA=1) - **Speed**: Up to 10 MHz - **Bit Order**: MSB first - **CS Polarity**: Active low (CS) - **Data Format**: 8-bit data words ## Load Connections ### Half-Bridge Mode In half-bridge mode, connect the load between OUTA and GND: ```cpp OUTA ‚îÄ‚îÄ‚îÄ‚îÄ[Load]‚îÄ‚îÄ‚îÄ‚îÄ GND OUTB ‚îÄ‚îÄ‚îÄ‚îÄ (not used) ``` ### Full-Bridge Mode In full-bridge mode, connect the load between OUTA and OUTB: ```cpp OUTA ‚îÄ‚îÄ‚îÄ‚îÄ[Load]‚îÄ‚îÄ‚îÄ‚îÄ OUTB ``` ## Physical Layout Recommendations - Keep SPI traces short (< 10cm recommended) - Use ground plane for noise reduction - Place decoupling capacitors (100nF ceramic + 10¬µF tantalum) close to VDD pin - Route clock and data lines away from noise sources - Keep high-current traces (OUTA/OUTB) away from sensitive signals - Use appropriate trace widths for high-current paths - Add flyback diodes for inductive loads (solenoids, motors) ## Example Wiring Diagram ```text MAX22200 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ VDD ‚îÇ GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ GND ‚îÇ SCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SCLK ‚îÇ MOSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SDI ‚îÇ MISO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SDO ‚îÇ CS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ CS ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ OUT0A ‚îú‚îÄ‚îÄ‚îÄ[Solenoid]‚îÄ‚îÄ‚îÄ GND ‚îÇ ‚îÇ OUT0B (not used in half-bridge) ``` ## Protection Components ### Flyback Diodes For inductive loads (solenoids, motors), add flyback diodes: ```cpp OUTA ‚îÄ‚îÄ‚îÄ‚îÄ[Flyback Diode]‚îÄ‚îÄ‚îÄ OUTB (cathode to OUTA) ``` ### Current Limiting The MAX22200 has built-in overcurrent protection (OCP), but you may want to add external current limiting for additional safety. ## Next Steps - Verify connections with a multimeter - Proceed to [Quick Start](/hf-max22200-driver/development/docs/quickstart.html) to test the connection - Review [Platform Integration](/hf-max22200-driver/development/docs/platform_integration.html) for software setup --- **Navigation** ‚¨ÖÔ∏è [Quick Start](/hf-max22200-driver/development/docs/quickstart.html) | [Next: Platform Integration ‚û°Ô∏è](/hf-max22200-driver/development/docs/platform_integration.html) | [Back to Index](/hf-max22200-driver/development/docs/) ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup.html",
    
    "relUrl": "/docs/hardware_setup.html"
  },"4": {
    "doc": "HF-MAX22200 Documentation",
    "title": "HF-MAX22200 Documentation",
    "content": "# HF-MAX22200 Documentation Welcome! This directory contains step-by-step guides for installing, building, and using the **HF-MAX22200** library. ## üìö Documentation Structure ### **Getting Started** 1. **[üõ†Ô∏è Installation](/hf-max22200-driver/development/docs/installation.html)** ‚Äì Prerequisites and how to obtain the source 2. **[‚ö° Quick Start](/hf-max22200-driver/development/docs/quickstart.html)** ‚Äì Minimal working example to get you running 3. **[üîå Hardware Setup](/hf-max22200-driver/development/docs/hardware_setup.html)** ‚Äì Wiring diagrams and pin connections ### **Integration** 1. **[üîß Platform Integration](/hf-max22200-driver/development/docs/platform_integration.html)** ‚Äì Implement the CRTP SPI interface for your platform 2. **[‚öôÔ∏è Configuration](/hf-max22200-driver/development/docs/configuration.html)** ‚Äì Configuration options and settings ### **Reference** 1. **[üìñ API Reference](api_reference.md)** ‚Äì Complete API documentation 2. **[üí° Examples](/hf-max22200-driver/development/docs/examples.html)** ‚Äì Detailed example walkthroughs ### **Troubleshooting** 1. **[üêõ Troubleshooting](/hf-max22200-driver/development/docs/troubleshooting.html)** ‚Äì Common issues and solutions --- ## üöÄ Quick Start Path **New to MAX22200?** Follow this recommended path: 1. Start with **[Installation](/hf-max22200-driver/development/docs/installation.html)** to prepare your environment 2. Follow **[Hardware Setup](/hf-max22200-driver/development/docs/hardware_setup.html)** to wire your hardware 3. Read **[Quick Start](/hf-max22200-driver/development/docs/quickstart.html)** for a minimal working example 4. Check **[Platform Integration](/hf-max22200-driver/development/docs/platform_integration.html)** to implement the SPI interface 5. Explore **[Examples](/hf-max22200-driver/development/docs/examples.html)** for more advanced usage --- ## üí° Need Help? - **üêõ Found a bug?** Check the [Troubleshooting](/hf-max22200-driver/development/docs/troubleshooting.html) guide - **‚ùì Have questions?** Review the [API Reference](api_reference.md) - **üìù Want to contribute?** See the contributing guidelines in the main README --- **Navigation** ‚û°Ô∏è [Installation](/hf-max22200-driver/development/docs/installation.html) ",
    "url": "/hf-max22200-driver/development/docs/",
    
    "relUrl": "/docs/"
  },"5": {
    "doc": "Installation",
    "title": "Installation",
    "content": "# Installation This guide covers how to obtain and integrate the MAX22200 driver library into your project. ## Prerequisites Before installing the driver, ensure you have: - **C++20 Compiler**: GCC 10+, Clang 12+, or MSVC 2019+ - **Build System**: Make, CMake, or ESP-IDF (depending on your platform) - **Platform SDK**: ESP-IDF, STM32 HAL, Arduino, or your platform's SPI driver ## Obtaining the Source ### Option 1: Git Clone ```bash git clone https://github.com/n3b3x/hf-max22200-driver.git cd hf-max22200-driver ``` ### Option 2: Copy Files Copy the following files into your project: ``` inc/ ‚îú‚îÄ‚îÄ max22200.hpp ‚îú‚îÄ‚îÄ max22200_spi_interface.hpp ‚îú‚îÄ‚îÄ max22200_registers.hpp ‚îî‚îÄ‚îÄ max22200_types.hpp src/ ‚îî‚îÄ‚îÄ max22200.cpp ``` ## Integration Methods ### Using CMake Add the driver as a subdirectory in your `CMakeLists.txt`: ```cmake add_subdirectory(external/hf-max22200-driver) target_link_libraries(your_target PRIVATE hf_max22200) target_include_directories(your_target PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/external/hf-max22200-driver/inc ) ``` ### Using ESP-IDF Component The driver can be used as an ESP-IDF component. Add it to your `components` directory: ```cmake # In your main CMakeLists.txt idf_component_register( SRCS \"your_code.cpp\" INCLUDE_DIRS \".\" REQUIRES hf_max22200 ) ``` ### Manual Integration 1. Copy the driver files to your project 2. Add the `inc/` directory to your include path 3. Include the header: ```cpp #include \"max22200.hpp\" ``` 4. Compile with C++20 support: ```bash g++ -std=c++20 -I inc/ your_code.cpp src/max22200.cpp ``` ## Verification To verify the installation: 1. Include the header in a test file: ```cpp #include \"max22200.hpp\" ``` 2. Compile a simple test: ```bash g++ -std=c++20 -I inc/ -c src/max22200.cpp -o test.o ``` 3. If compilation succeeds, the library is properly installed. ## Next Steps - Follow the [Quick Start](/hf-max22200-driver/development/docs/quickstart.html) guide to create your first application - Review [Hardware Setup](/hf-max22200-driver/development/docs/hardware_setup.html) for wiring instructions - Check [Platform Integration](/hf-max22200-driver/development/docs/platform_integration.html) to implement the SPI interface --- **Navigation** ‚¨ÖÔ∏è [Back to Index](/hf-max22200-driver/development/docs/) | [Next: Quick Start ‚û°Ô∏è](/hf-max22200-driver/development/docs/quickstart.html) ",
    "url": "/hf-max22200-driver/development/docs/installation.html",
    
    "relUrl": "/docs/installation.html"
  },"6": {
    "doc": "Platform Integration Guide",
    "title": "Platform Integration Guide",
    "content": "# Platform Integration Guide This guide explains how to implement the hardware abstraction interface for the MAX22200 driver on your platform. ## Understanding CRTP (Curiously Recurring Template Pattern) The MAX22200 driver uses **CRTP** (Curiously Recurring Template Pattern) for hardware abstraction. This design choice provides several critical benefits for embedded systems: ### Why CRTP Instead of Virtual Functions? #### 1. **Zero Runtime Overhead** - **Virtual functions**: Require a vtable lookup (indirect call) = ~5-10 CPU cycles overhead per call - **CRTP**: Direct function calls = 0 overhead, compiler can inline - **Impact**: In time-critical embedded code controlling solenoids/motors, this matters significantly #### 2. **Compile-Time Polymorphism** - **Virtual functions**: Runtime dispatch - the compiler cannot optimize across the abstraction boundary - **CRTP**: Compile-time dispatch - full optimization, dead code elimination, constant propagation - **Impact**: Smaller code size, faster execution #### 3. **Memory Efficiency** - **Virtual functions**: Each object needs a vtable pointer (4-8 bytes) - **CRTP**: No vtable pointer needed - **Impact**: Critical in memory-constrained systems #### 4. **Type Safety** - **Virtual functions**: Runtime errors if method not implemented - **CRTP**: Compile-time errors if method not implemented - **Impact**: Catch bugs at compile time, not in the field ### How CRTP Works ```cpp // Base template class (from max22200_spi_interface.hpp) template class SpiInterface { public: bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { // Cast 'this' to Derived* and call the derived implementation return static_cast(this)->Transfer(tx_data, rx_data, length); } }; // Your implementation class MySPI : public max22200::SpiInterface { public: // This method is called directly (no virtual overhead) bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { // Your platform-specific SPI code } }; ```cpp ## Interface Definition The MAX22200 driver requires you to implement the following interface: ```cpp template class SpiInterface { public: // Required methods (implement all of these) bool Initialize(); bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length); void SetChipSelect(bool state); bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first = true); bool IsReady() const; }; ```cpp ## Implementation Steps ### Step 1: Create Your Implementation Class ```cpp #include \"max22200_spi_interface.hpp\" class MyPlatformSPI : public max22200::SpiInterface { private: // Your platform-specific members spi_device_handle_t spi_device_; // Example for ESP32 public: // Constructor MyPlatformSPI(spi_device_handle_t device) : spi_device_(device) {} // Implement required methods bool Initialize() { // Your initialization code return true; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { // Your transfer code return true; } void SetChipSelect(bool state) { // Your CS control code } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // Your configuration code return true; } bool IsReady() const { // Check if SPI is ready return true; } }; ``` ### Step 2: Platform-Specific Examples #### ESP32 (ESP-IDF) ```cpp #include \"driver/spi_master.h\" #include \"max22200_spi_interface.hpp\" class Esp32SPIBus : public max22200::SpiInterface { private: spi_device_handle_t spi_device_; gpio_num_t cs_pin_; public: Esp32SPIBus(spi_host_device_t host, const spi_device_interface_config_t& config, gpio_num_t cs) { spi_bus_add_device(host, &config, &spi_device_); cs_pin_ = cs; } bool Initialize() { return spi_device_ != nullptr; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { spi_transaction_t trans = {}; trans.length = length * 8; trans.tx_buffer = tx_data; trans.rx_buffer = rx_data; esp_err_t ret = spi_device_transmit(spi_device_, &trans); return ret == ESP_OK; } void SetChipSelect(bool state) { gpio_set_level(cs_pin_, state ? 0 : 1); // Active low } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // ESP-IDF handles this via device config return true; } bool IsReady() const { return spi_device_ != nullptr; } }; ``` #### STM32 (HAL) ```cpp #include \"stm32f4xx_hal.h\" #include \"max22200_spi_interface.hpp\" extern SPI_HandleTypeDef hspi1; class STM32SPIBus : public max22200::SpiInterface { private: GPIO_TypeDef* cs_port_; uint16_t cs_pin_; public: STM32SPIBus(GPIO_TypeDef* cs_port, uint16_t cs_pin) : cs_port_(cs_port), cs_pin_(cs_pin) {} bool Initialize() { return HAL_SPI_Init(&hspi1) == HAL_OK; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { SetChipSelect(true); // Assert CS HAL_StatusTypeDef status = HAL_SPI_TransmitReceive(&hspi1, (uint8_t*)tx_data, rx_data, length, HAL_MAX_DELAY); SetChipSelect(false); // Deassert CS return status == HAL_OK; } void SetChipSelect(bool state) { HAL_GPIO_WritePin(cs_port_, cs_pin_, state ? GPIO_PIN_RESET : GPIO_PIN_SET); } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // STM32 HAL handles this via SPI init return true; } bool IsReady() const { return hspi1.State == HAL_SPI_STATE_READY; } }; ``` #### Arduino ```cpp #include #include \"max22200_spi_interface.hpp\" class ArduinoSPIBus : public max22200::SpiInterface { private: uint8_t cs_pin_; public: ArduinoSPIBus(uint8_t cs_pin) : cs_pin_(cs_pin) { pinMode(cs_pin_, OUTPUT); digitalWrite(cs_pin_, HIGH); } bool Initialize() { SPI.begin(); return true; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { SPI.beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0)); SetChipSelect(true); for (size_t i = 0; i { public: virtual bool Transfer(...) override { // ‚ùå Virtual keyword not needed // ... } }; ``` ### ‚úÖ Correct CRTP Implementation ```cpp // CORRECT - no virtual keyword class MyBus : public max22200::SpiInterface { public: bool Transfer(...) { // ‚úÖ Direct implementation // ... } }; ``` ### ‚ùå Don't Forget the Template Parameter ```cpp // WRONG - missing template parameter class MyBus : public max22200::SpiInterface { // ‚ùå Compiler error // ... }; ``` ### ‚úÖ Correct Template Parameter ```cpp // CORRECT - pass your class as template parameter class MyBus : public max22200::SpiInterface { // ‚úÖ // ... }; ``` ## Testing Your Implementation After implementing the interface, test it: ```cpp MyPlatformSPI spi(/* your config */); max22200::MAX22200 driver(spi); if (driver.Initialize() == max22200::DriverStatus::OK) { // Test basic operations max22200::ChannelConfig config; config.enabled = true; driver.ConfigureChannel(0, config); } ``` ## Next Steps - See [Configuration](/hf-max22200-driver/development/docs/configuration.html) for driver configuration options - Check [Examples](/hf-max22200-driver/development/docs/examples.html) for complete usage examples - Review [API Reference](api_reference.md) for all available methods --- **Navigation** ‚¨ÖÔ∏è [Hardware Setup](/hf-max22200-driver/development/docs/hardware_setup.html) | [Next: Configuration ‚û°Ô∏è](/hf-max22200-driver/development/docs/configuration.html) ",
    "url": "/hf-max22200-driver/development/docs/platform_integration.html",
    
    "relUrl": "/docs/platform_integration.html"
  },"7": {
    "doc": "Quick Start",
    "title": "Quick Start",
    "content": "# Quick Start This guide will get you up and running with the MAX22200 driver in just a few steps. ## Prerequisites - [Driver installed](/hf-max22200-driver/development/docs/installation.html) - [Hardware wired](/hf-max22200-driver/development/docs/hardware_setup.html) - [SPI interface implemented](/hf-max22200-driver/development/docs/platform_integration.html) ## Minimal Example Here's a complete working example: ```cpp #include \"max22200.hpp\" // 1. Implement the SPI interface class MySpi : public max22200::SpiInterface { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Your SPI transfer implementation // Assert CS, transfer data, deassert CS } }; // 2. Create instances MySpi spi; max22200::MAX22200 driver(spi); // 3. Initialize if (driver.Initialize() == max22200::DriverStatus::OK) { // 4. Configure channel 0 max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 500; // 500 mA hit current config.hold_current = 200; // 200 mA hold current config.hit_time = 1000; // 1000 ms hit time driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); } ``` ## Step-by-Step Explanation ### Step 1: Include the Header ```cpp #include \"max22200.hpp\" ``` This includes the main driver class and all necessary types. ### Step 2: Implement the SPI Interface You need to implement the `SpiInterface` for your platform. See [Platform Integration](/hf-max22200-driver/development/docs/platform_integration.html) for detailed examples. ```cpp class MySpi : public max22200::SpiInterface { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Assert chip select // Perform SPI transfer // Deassert chip select } }; ``` ### Step 3: Create Driver Instance ```cpp MySpi spi; max22200::MAX22200 driver(spi); ``` The constructor takes a reference to your SPI interface implementation. ### Step 4: Initialize ```cpp if (driver.Initialize() == max22200::DriverStatus::OK) { // Driver is ready } ``` ### Step 5: Configure Channel ```cpp max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; // Current Drive Regulation config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 500; // Hit current in mA (0-1023) config.hold_current = 200; // Hold current in mA (0-1023) config.hit_time = 1000; // Hit time in ms (0-65535) driver.ConfigureChannel(0, config); ``` ### Step 6: Enable Channel ```cpp driver.EnableChannel(0, true); ``` ## Complete Example with Error Handling ```cpp #include \"max22200.hpp\" class MySpi : public max22200::SpiInterface { // ... SPI implementation }; void app_main() { MySpi spi; max22200::MAX22200 driver(spi); // Initialize max22200::DriverStatus status = driver.Initialize(); if (status != max22200::DriverStatus::OK) { printf(\"Initialization failed\\n\"); return; } // Configure channel max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.bridge_mode = max22200::BridgeMode::HALF_BRIDGE; config.hit_current = 500; config.hold_current = 200; config.hit_time = 1000; status = driver.ConfigureChannel(0, config); if (status != max22200::DriverStatus::OK) { printf(\"Channel configuration failed\\n\"); return; } // Enable channel driver.EnableChannel(0, true); // Read current uint16_t current; if (driver.ReadCurrent(0, current) == max22200::DriverStatus::OK) { printf(\"Channel 0 current: %u mA\\n\", current); } } ``` ## Expected Output When running this example, you should see: ``` Channel 0 current: 500 mA ``` ## Troubleshooting If you encounter issues: - **Compilation errors**: Check that you've implemented the `transfer()` method in your SPI interface - **Initialization fails**: Verify SPI connections and hardware setup - **Channel not working**: Check channel configuration and enable state - **See**: [Troubleshooting](/hf-max22200-driver/development/docs/troubleshooting.html) for common issues ## Next Steps - Explore [Examples](/hf-max22200-driver/development/docs/examples.html) for more advanced usage - Review the [API Reference](api_reference.md) for all available methods - Check [Configuration](/hf-max22200-driver/development/docs/configuration.html) for customization options --- **Navigation** ‚¨ÖÔ∏è [Installation](/hf-max22200-driver/development/docs/installation.html) | [Next: Hardware Setup ‚û°Ô∏è](/hf-max22200-driver/development/docs/hardware_setup.html) | [Back to Index](/hf-max22200-driver/development/docs/) ",
    "url": "/hf-max22200-driver/development/docs/quickstart.html",
    
    "relUrl": "/docs/quickstart.html"
  },"8": {
    "doc": "Troubleshooting",
    "title": "Troubleshooting",
    "content": "# Troubleshooting This guide helps you diagnose and resolve common issues when using the MAX22200 driver. ## Common Error Messages ### Error: Initialization Failed **Symptoms:** - `Initialize()` returns `INITIALIZATION_ERROR` - Driver not responding **Causes:** - SPI interface not properly initialized - Hardware connections incorrect - Power supply issues **Solutions:** 1. **Verify SPI Interface**: Ensure SPI interface is initialized before creating driver 2. **Check Connections**: Verify all SPI connections (SCLK, SDI, SDO, CS) 3. **Verify Power**: Check power supply voltage (2.7V - 5.5V) 4. **Check CS Line**: Verify chip select is properly controlled --- ### Error: Communication Error **Symptoms:** - `COMMUNICATION_ERROR` returned from methods - No response from device **Causes:** - SPI configuration incorrect - Signal integrity issues - CS timing problems **Solutions:** 1. **Check SPI Mode**: Ensure SPI Mode 0 or Mode 3 2. **Verify Speed**: Try lower SPI speed (e.g., 1 MHz) 3. **Check CS Timing**: Verify CS assertion/deassertion timing 4. **Verify Connections**: Check all SPI connections are secure --- ### Error: Channel Not Working **Symptoms:** - Channel enabled but no output - Current not flowing **Causes:** - Channel not properly configured - Channel not enabled - Load not connected correctly - Fault condition **Solutions:** 1. **Check Configuration**: Verify channel configuration is correct 2. **Check Enable State**: Ensure channel is enabled via `EnableChannel()` 3. **Verify Load**: Check load connections (OUTA/OUTB to load) 4. **Check Faults**: Read fault status to identify issues --- ### Error: Overcurrent Protection (OCP) **Symptoms:** - `FaultStatus.overcurrent_protection` is true - Channel disabled automatically **Causes:** - Load current exceeds limits - Short circuit - Incorrect current settings **Solutions:** 1. **Check Load**: Verify load is within specifications (1A RMS max per channel) 2. **Reduce Current**: Lower hit_current and hold_current settings 3. **Check for Shorts**: Verify no short circuits in wiring 4. **Clear Fault**: Read fault status to clear, then reconfigure --- ### Error: Open Load Detection **Symptoms:** - `FaultStatus.open_load` is true - No current flow **Causes:** - Load not connected - Broken connection - Load impedance too high **Solutions:** 1. **Check Connections**: Verify load is properly connected 2. **Check Wiring**: Inspect for broken wires 3. **Verify Load**: Ensure load impedance is appropriate --- ## Hardware Issues ### Device Not Responding **Checklist:** - [ ] Verify power supply voltage is 2.7V - 5.5V - [ ] Check all SPI connections are secure - [ ] Verify CS line is properly controlled - [ ] Check for short circuits - [ ] Use oscilloscope/logic analyzer to verify bus activity --- ### Incorrect Current Readings **Symptoms:** - Current readings don't match expected values - ICS readings are zero or incorrect **Causes:** - ICS not enabled - Channel not active - Incorrect configuration **Solutions:** 1. **Enable ICS**: Call `SetIntegratedCurrentSensing(true)` 2. **Check Channel State**: Verify channel is enabled and active 3. **Verify Configuration**: Check current settings are correct --- ## Software Issues ### Compilation Errors **Error: \"No matching function\"** **Solution:** - Ensure you've implemented all required SPI interface methods - Check method signatures match the interface definition **Error: \"Undefined reference\"** **Solution:** - Verify you're linking the driver source file - Check include paths are correct --- ### Runtime Errors **Initialization Fails** **Checklist:** - [ ] SPI bus interface is properly initialized - [ ] Hardware connections are correct - [ ] Configuration parameters are valid - [ ] Device is powered and ready **Unexpected Behavior** **Checklist:** - [ ] Verify configuration matches your use case - [ ] Check for timing issues - [ ] Review error handling code - [ ] Check fault status --- ## Debugging Tips ### Enable Diagnostics ```cpp max22200::MAX22200 driver(spi, true); // Enable diagnostics ``` ### Check Fault Status ```cpp max22200::FaultStatus faults; driver.ReadFaultStatus(faults); if (faults.hasFault()) { printf(\"Faults detected: %d\\n\", faults.getFaultCount()); } ``` ### Read Channel Status ```cpp max22200::ChannelStatus status; driver.ReadChannelStatus(0, status); printf(\"Channel 0: enabled=%d, fault=%d, current=%u\\n\", status.enabled, status.fault_active, status.current_reading); ``` ### Use Callbacks Set up fault callbacks to get notified immediately when faults occur: ```cpp void fault_handler(uint8_t channel, max22200::FaultType fault_type, void *user_data) { printf(\"Fault on channel %d\\n\", channel); } driver.SetFaultCallback(fault_handler); ``` --- ## FAQ ### Q: What is the maximum current per channel? **A:** Each channel can handle up to 1A RMS. The hit_current and hold_current settings use 10-bit values (0-1023) that map to the actual current range. ### Q: Can I use multiple channels simultaneously? **A:** Yes, all 8 channels can be used simultaneously. Each channel is independent. ### Q: What's the difference between CDR and VDR modes? **A:** CDR (Current Drive Regulation) regulates current during both hit and hold phases. VDR (Voltage Drive Regulation) applies constant voltage during hit phase and regulates current during hold phase. ### Q: How do I clear a fault? **A:** Read the fault status register to clear latched faults. Some faults (like OCP) may require reconfiguring the channel. ### Q: What is Integrated Current Sensing (ICS)? **A:** ICS allows reading the actual current flowing through each channel without external sense resistors. Enable it with `SetIntegratedCurrentSensing(true)`. --- ## Getting More Help If you're still experiencing issues: 1. Check the [API Reference](api_reference.md) for method details 2. Review [Examples](/hf-max22200-driver/development/docs/examples.html) for working code 3. Search existing issues on GitHub 4. Open a new issue with: - Description of the problem - Steps to reproduce - Hardware setup details - Error messages/logs --- **Navigation** ‚¨ÖÔ∏è [Examples](/hf-max22200-driver/development/docs/examples.html) | [Back to Index](/hf-max22200-driver/development/docs/) ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting.html",
    
    "relUrl": "/docs/troubleshooting.html"
  },"9": {
    "doc": "HF-MAX22200 Driver",
    "title": "HF-MAX22200 Driver",
    "content": "# HF-MAX22200 Driver **Portable C++20 driver for the MAX22200 octal solenoid and motor driver with SPI interface** [![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0) ## üìö Table of Contents 1. [Overview](#-overview) 2. [Features](#-features) 3. [Quick Start](#-quick-start) 4. [Installation](#-installation) 5. [API Reference](#-api-reference) 6. [Examples](#-examples) 7. [Documentation](#-documentation) 8. [Contributing](#-contributing) 9. [License](#-license) ## üì¶ Overview > **üìñ [üìöüåê Live Complete Documentation](https://n3b3x.github.io/hf-max22200-driver/)** - > Interactive guides, examples, and step-by-step tutorials **HF-MAX22200** is a portable C++20 driver for the **MAX22200** octal (eight-channel) solenoid and motor driver IC. The MAX22200 features eight half-bridges, each capable of handling up to 36V and 1A RMS, with integrated current sensing, current/voltage regulation, and comprehensive protection features. The driver uses a CRTP-based `SpiInterface` for hardware abstraction, allowing it to run on any platform (ESP32, STM32, Arduino, etc.) with zero runtime overhead. It implements all major features from the MAX22200 datasheet including channel configuration, current/voltage regulation modes, integrated current sensing (ICS), fault detection, and callback support for event-driven programming. ## ‚ú® Features - ‚úÖ **Eight Half-Bridges**: Each channel handles up to 36V and 1A RMS - ‚úÖ **Current and Voltage Regulation**: Supports both CDR (Current Drive Regulation) and VDR (Voltage Drive Regulation) modes - ‚úÖ **Integrated Current Sensing (ICS)**: Real-time current monitoring without external sense resistors - ‚úÖ **Half-Bridge and Full-Bridge Modes**: Flexible bridge configurations - ‚úÖ **HIT/HOLD Current Control**: Programmable hit current, hold current, and hit time - ‚úÖ **Comprehensive Protection**: OCP, OL, DPM, UVLO, TSD, and fault registers - ‚úÖ **Hardware Agnostic**: SPI interface for platform independence - ‚úÖ **Modern C++**: C++20 with CRTP-based design - ‚úÖ **Zero Overhead**: CRTP-based design for compile-time polymorphism - ‚úÖ **Callback Support**: Event-driven programming with fault and state callbacks - ‚úÖ **Statistics Tracking**: Runtime performance and error monitoring ## üöÄ Quick Start ```cpp #include \"max22200.hpp\" // 1. Implement the SPI interface (see platform_integration.md) class MySpi : public max22200::SpiInterface { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Your SPI transfer implementation } }; // 2. Create driver instance MySpi spi; max22200::MAX22200 driver(spi); // 3. Initialize if (driver.Initialize() == max22200::DriverStatus::OK) { // 4. Configure channel 0 max22200::ChannelConfig config; config.enabled = true; config.drive_mode = max22200::DriveMode::CDR; config.hit_current = 500; config.hold_current = 200; config.hit_time = 1000; driver.ConfigureChannel(0, config); driver.EnableChannel(0, true); } ``` For detailed setup, see [Installation](/hf-max22200-driver/development/docs/installation.html) and [Quick Start Guide](/hf-max22200-driver/development/docs/quickstart.html). ## üîß Installation 1. **Clone or copy** the driver files into your project 2. **Implement the SPI interface** for your platform (see [Platform Integration](/hf-max22200-driver/development/docs/platform_integration.html)) 3. **Include the header** in your code: ```cpp #include \"max22200.hpp\" ``` 4. Compile with a **C++20** or newer compiler For detailed installation instructions, see [docs/installation.md](/hf-max22200-driver/development/docs/installation.html). ## üìñ API Reference | Method | Description |--------|-------------| `Initialize()` | Initialize the driver | `Deinitialize()` | Safely shut down the driver | `Reset()` | Perform software reset | `ConfigureChannel()` | Configure a channel | `EnableChannel()` | Enable/disable a channel | `GetChannelStatus()` | Get channel status | `GetFaultStatus()` | Get fault status | `ReadCurrent()` | Read current via ICS | `SetSleepMode()` | Enable/disable sleep mode | `SetFaultCallback()` | Set fault callback function | `GetStatistics()` | Get driver statistics | For complete API documentation, see [docs/api_reference.md](docs/api_reference.md). ## üìä Examples For ESP32 examples, see the [examples/esp32](examples/esp32/) directory. Additional examples for other platforms are available in the [examples](examples/) directory. Detailed example walkthroughs are available in [docs/examples.md](/hf-max22200-driver/development/docs/examples.html). ## üìö Documentation For complete documentation, see the [docs directory](/hf-max22200-driver/development/docs/). ## ü§ù Contributing Pull requests and suggestions are welcome! Please follow the existing code style and include tests for new features. ## üìÑ License This project is licensed under the **GNU General Public License v3.0**. See the [LICENSE](/hf-max22200-driver/development/LICENSE) file for details. ",
    "url": "/hf-max22200-driver/development/",
    
    "relUrl": "/"
  },"10": {
    "doc": "MAX22200 ESP32-C6 Comprehensive Test Suite",
    "title": "MAX22200 ESP32-C6 Comprehensive Test Suite",
    "content": "# MAX22200 ESP32-C6 Comprehensive Test Suite This directory contains comprehensive test suites for the MAX22200 octal solenoid and motor driver using the ESP32-C6 DevKit-M-1. ## üìã Table of Contents - [Hardware Overview](#-hardware-overview) - [Pin Connections](#-pin-connections) - [Hardware Setup](#-hardware-setup) - [Building the Tests](#-building-the-tests) - [Running the Tests](#-running-the-tests) - [Test Suites](#-test-suites) - [Troubleshooting](#-troubleshooting) --- ## üîå Hardware Overview ### ESP32-C6 DevKit-M-1 The ESP32-C6 DevKit-M-1 serves as the host controller for communicating with the MAX22200 driver via SPI. ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ESP32-C6 DevKit-M-1 ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ESP32-C6 Microcontroller ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ GPIO Pins: ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ SPI: MOSI (GPIO7), MISO (GPIO2), ‚îÇ ‚îÇ ‚îÇ ‚îÇ SCLK (GPIO6), CS (GPIO10) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Test Indicator: GPIO14 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ USB-C Connector ‚îÇ ‚îÇ (Power + Serial Communication) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` ### MAX22200 Octal Solenoid and Motor Driver The MAX22200 is an octal (eight-channel) solenoid and motor driver featuring: - **Eight Half-Bridges**: Each capable of handling up to 36V and 1A RMS - **Current and Voltage Regulation**: Supports both CDR and VDR modes - **Integrated Lossless Current Sensing (ICS)**: Real-time current monitoring - **High-Speed SPI Interface**: Up to 10MHz communication - **Comprehensive Protection**: OCP, OL, DPM, UVLO, TSD, and fault registers ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ MAX22200 Octal Driver ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ MAX22200 IC ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ Features: ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ 8 half-bridge channels (OUT0-OUT7) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ SPI interface (up to 10MHz) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Current regulation (CDR mode) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Voltage regulation (VDR mode) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Integrated current sensing (ICS) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Fault detection and reporting ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Thermal shutdown protection ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ SPI Connections: ‚îÇ ‚îÇ ‚Ä¢ MOSI (Master Out Slave In) ‚îÇ ‚îÇ ‚Ä¢ MISO (Master In Slave Out) ‚îÇ ‚îÇ ‚Ä¢ SCLK (Serial Clock) ‚îÇ ‚îÇ ‚Ä¢ CS (Chip Select) ‚îÇ ‚îÇ ‚îÇ ‚îÇ Power Connections: ‚îÇ ‚îÇ ‚Ä¢ VCC (3.3V/5V Logic Power) ‚îÇ ‚îÇ ‚Ä¢ VDD (12V-36V Load Power) ‚îÇ ‚îÇ ‚Ä¢ GND (Ground) ‚îÇ ‚îÇ ‚îÇ ‚îÇ Control Pins: ‚îÇ ‚îÇ ‚Ä¢ RESET (Reset Input) ‚îÇ ‚îÇ ‚Ä¢ FAULT (Fault Status Output) ‚îÇ ‚îÇ ‚Ä¢ DIAG (Diagnostic Output) ‚îÇ ‚îÇ ‚Ä¢ SHDN (Shutdown Input) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` --- ## üìå Pin Connections ### SPI Bus Connections | MAX22200 Pin | ESP32-C6 GPIO | Function | Notes |--------------|---------------|----------|-------| MOSI | GPIO7 | SPI Data Out | Master to Slave | MISO | GPIO2 | SPI Data In | Slave to Master | SCLK | GPIO6 | SPI Clock | Clock signal | CS | GPIO10 | Chip Select | Active low | VCC | 3.3V | Logic Power | 3.3V or 5V | VDD | 12V-36V | Load Power | For solenoids/motors | GND | GND | Ground | Common ground | RESET | GPIO5 (optional) | Reset Input | Active low | FAULT | GPIO4 (optional) | Fault Status | Open-drain, requires pull-up | DIAG | GPIO3 (optional) | Diagnostic | Open-drain, requires pull-up | SHDN | GPIO1 (optional) | Shutdown | Active low | ### Test Indicator | Signal | ESP32-C6 GPIO | Function |--------|---------------|----------| Test Progress | GPIO14 | Visual test progression indicator | ### SPI Configuration Default SPI configuration (can be modified in test file): - **Mode**: Mode 0 (CPOL=0, CPHA=0) or Mode 3 (CPOL=1, CPHA=1) - **Bit Order**: MSB first - **Clock Speed**: Up to 10MHz (5MHz with daisy chaining) - **Data Width**: 8-bit transfers - **Chip Select**: Active low, controlled by software --- ## üõ†Ô∏è Hardware Setup ### Basic Setup 1. **Connect SPI Bus**: - Connect MAX22200 MOSI to ESP32-C6 GPIO7 - Connect MAX22200 MISO to ESP32-C6 GPIO2 - Connect MAX22200 SCLK to ESP32-C6 GPIO6 - Connect MAX22200 CS to ESP32-C6 GPIO10 2. **Power Connections**: - Connect MAX22200 VCC to ESP32-C6 3.3V (logic power) - Connect MAX22200 VDD to 12V-36V power supply (load power) - Connect MAX22200 GND to ESP32-C6 GND (common ground) 3. **Optional Control Pins**: - Connect MAX22200 RESET to ESP32-C6 GPIO5 (optional, can use software reset) - Connect MAX22200 FAULT to ESP32-C6 GPIO4 (optional, for fault monitoring) - Connect MAX22200 DIAG to ESP32-C6 GPIO3 (optional, for diagnostics) - Connect MAX22200 SHDN to ESP32-C6 GPIO1 (optional, for hardware shutdown) 4. **Load Connections**: - Connect solenoids or motors to OUT0-OUT7 pins - Ensure proper current ratings (max 1A RMS per channel) - Use appropriate flyback diodes for inductive loads ### Test Setup For comprehensive testing, you can connect: - Solenoids or motors to output channels (with appropriate current ratings) - Current measurement equipment for ICS verification - Logic analyzer on SPI bus for protocol verification - Oscilloscope for timing analysis --- ## üöÄ Building the Tests ### Prerequisites 1. **Install ESP-IDF** (if not already installed): ```bash # Clone ESP-IDF git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf # Checkout release version 5.5 git checkout release/v5.5 git submodule update --init --recursive # Install ESP-IDF (Linux/macOS) ./install.sh esp32c6 # Set up environment (add to ~/.bashrc or ~/.zshrc for persistence) ./export.sh ``` 2. **Navigate to ESP32 Examples**: ```bash cd examples/esp32 ``` 3. **Setup Repository** (First time only): ```bash # Make scripts executable and setup the build environment chmod +x scripts/*.sh ./scripts/setup_repo.sh ``` ### Available Test Applications The test suites use a centralized build system with scripts. Available applications: | **Application Name** | **Description** | **Hardware Required** |----------------------|----------------|----------------------| `max22200_comprehensive_test` | Comprehensive MAX22200 driver testing with all features | MAX22200 board | ### List Available Applications ```bash # List all available applications ./scripts/build_app.sh list ``` ### Build an Application ```bash # Build comprehensive test (Debug build) ./scripts/build_app.sh max22200_comprehensive_test Debug # Build comprehensive test (Release build) ./scripts/build_app.sh max22200_comprehensive_test Release ``` --- ## üì§ Running the Tests ### Flash Application ```bash # Flash the application to ESP32-C6 ./scripts/flash_app.sh max22200_comprehensive_test Debug # Or manually: idf.py -p /dev/ttyUSB0 flash ``` ### Monitor Output ```bash # Monitor serial output idf.py -p /dev/ttyUSB0 monitor # Or use the flash script which includes monitoring ./scripts/flash_app.sh max22200_comprehensive_test Debug ``` ### Auto-detect Port ```bash # The scripts can auto-detect the port ./scripts/detect_ports.sh ``` --- ## üß™ Test Suites ### Comprehensive Test Suite **Application**: `max22200_comprehensive_test` This comprehensive test suite validates all MAX22200 functionality: #### Test Sections 1. **Initialization Tests** - SPI bus initialization - Driver initialization - Reset to default state - Global configuration 2. **Channel Configuration Tests** - Single channel configuration - Multiple channel configuration - All channels configuration - Channel enable/disable 3. **Current Control Tests** - Hit current setting - Hold current setting - Current reading (ICS) - Current regulation (CDR mode) 4. **Voltage Control Tests** - Voltage regulation (VDR mode) - Voltage setting and reading 5. **Drive Mode Tests** - CDR (Current Drive Regulation) mode - VDR (Voltage Drive Regulation) mode - Bridge mode configuration 6. **Fault Detection Tests** - Overcurrent protection (OCP) - Overload (OL) detection - Dynamic power management (DPM) - Thermal shutdown (TSD) - Under-voltage lockout (UVLO) 7. **Diagnostic Tests** - Diagnostic mode enable/disable - Fault status reading - Fault callback registration 8. **Statistics Tests** - Operation statistics tracking - Error counting - Performance metrics 9. **Error Handling Tests** - Invalid channel handling - Error flag management - Error recovery 10. **Stress Tests** - Rapid channel operations - Continuous read/write cycles - Multi-channel simultaneous operations #### Test Configuration You can enable/disable specific test sections by editing the test file: ```cpp // In MAX22200ComprehensiveTest.cpp static constexpr bool ENABLE_BASIC_TESTS = true; // ... etc ``` #### Test Results The test framework provides: - Automatic pass/fail tracking - Execution time measurement - GPIO14 progress indicator (toggles on each test) - Comprehensive test summary - Success percentage calculation --- ## üîß Configuration ### SPI Bus Configuration Default SPI configuration (can be modified in test file): ```cpp // SPI configuration for MAX22200 // Mode: 0 (CPOL=0, CPHA=0) or 3 (CPOL=1, CPHA=1) // Speed: Up to 10MHz // Bit Order: MSB first ``` ### MAX22200 Configuration Default MAX22200 settings (can be modified in test file): ```cpp // Global configuration GlobalConfig global_config; global_config.diagnostic_enable = true; global_config.ics_enable = true; global_config.daisy_chain_mode = false; global_config.sleep_mode = false; // Channel configuration ChannelConfig channel_config; channel_config.enabled = true; channel_config.drive_mode = DriveMode::CDR; channel_config.hit_current = 500; // mA channel_config.hold_current = 200; // mA ``` --- ## üêõ Troubleshooting ### SPI Communication Failures **Symptoms**: Tests fail with SPI errors **Solutions**: 1. **Check SPI connections**: - Verify MOSI/MISO/SCLK/CS connections - Ensure proper power connections - Check for loose connections 2. **Verify SPI configuration**: - Check SPI mode (0 or 3) - Verify clock speed (reduce if using long wires) - Ensure CS is properly controlled 3. **Verify power supply**: - Ensure 3.3V logic power is stable - Check 12V-36V load power is present - Check for voltage drops ### Build Errors **Symptoms**: CMake or compilation errors **Solutions**: 1. **Verify ESP-IDF version**: ```bash idf.py --version # Should show ESP-IDF v5.5 or compatible ``` 2. **Clean and rebuild**: ```bash idf.py fullclean ./scripts/build_app.sh max22200_comprehensive_test Debug ``` 3. **Check component paths**: - Verify component CMakeLists.txt paths - Ensure source files are accessible ### Test Failures **Symptoms**: Specific tests fail **Solutions**: 1. **Check hardware connections**: - Verify all pins are properly connected - Check for loose connections - Verify load connections (solenoids/motors) 2. **Review test logs**: - Check which specific test failed - Review error messages in serial output 3. **Verify device state**: - Reset MAX22200 (power cycle or software reset) - Run reset test first 4. **Check current/voltage settings**: - Verify current settings are within limits (max 1A RMS) - Check voltage supply is within range (12V-36V) --- ## üìö Additional Resources - [MAX22200 Datasheet](/hf-max22200-driver/development/datasheet/MAX22200.pdf) - [Driver API Documentation](../../docs/api_reference.md) - [Hardware Integration Guide](../../docs/hardware_guide.md) - [ASCII Diagrams](../../docs/ascii_diagrams.md) --- ## üéØ Quick Reference ### Build Commands ```bash # List available apps ./scripts/build_app.sh list # Build comprehensive test ./scripts/build_app.sh max22200_comprehensive_test Debug # Flash and monitor ./scripts/flash_app.sh max22200_comprehensive_test Debug ``` ### Test Execution The comprehensive test suite runs automatically on boot and provides: - Real-time test progress via GPIO14 indicator - Serial output with detailed test results - Automatic test summary at completion ### GPIO14 Test Indicator GPIO14 toggles between HIGH/LOW for each completed test, providing visual feedback: - Use oscilloscope or logic analyzer to monitor - Useful for automated test verification - Blinks 5 times at section start/end --- ## üìù Notes - **SPI Configuration**: Use Mode 0 or Mode 3, MSB first, up to 10MHz clock - **Power Requirements**: 3.3V/5V for logic, 12V-36V for load power - **Current Limits**: Maximum 1A RMS per channel - **Test Duration**: Comprehensive test suite takes approximately 2-5 minutes to complete - **Hardware Requirements**: Basic tests work without external hardware; some tests require solenoids/motors connected --- üéØ Ready to test the MAX22200? Start with: ./scripts/build_app.sh max22200_comprehensive_test Debug ",
    "url": "/hf-max22200-driver/development/examples/esp32/",
    
    "relUrl": "/examples/esp32/"
  }
}
