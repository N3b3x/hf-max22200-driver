{"0": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "HF-MAX22200 Driver",
    "content": "Portable C++20 driver for the MAX22200 octal solenoid and motor driver with SPI interface . ",
    "url": "/hf-max22200-driver/development/#hf-max22200-driver",
    
    "relUrl": "/#hf-max22200-driver"
  },"1": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üìö Table of Contents",
    "content": ". | Overview | Features | Quick Start | Installation | API Reference | Examples | Documentation | Contributing | License | . ",
    "url": "/hf-max22200-driver/development/#-table-of-contents",
    
    "relUrl": "/#-table-of-contents"
  },"2": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üì¶ Overview",
    "content": "üìñ üìöüåê Live Complete Documentation - Interactive guides, examples, and step-by-step tutorials . HF-MAX22200 is a portable C++20 driver for the MAX22200 octal (eight-channel) solenoid and motor driver IC. The MAX22200 features eight half-bridges, each capable of handling up to 36V and 1A RMS, with integrated current sensing, current/voltage regulation, and comprehensive protection features. The driver uses a CRTP-based SpiInterface for hardware abstraction, allowing it to run on any platform (ESP32, STM32, Arduino, etc.) with zero runtime overhead. It implements all major features from the MAX22200 datasheet including channel configuration, current/voltage regulation modes, integrated current sensing (ICS), fault detection, and callback support for event-driven programming. ",
    "url": "/hf-max22200-driver/development/#-overview",
    
    "relUrl": "/#-overview"
  },"3": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "‚ú® Features",
    "content": ". | ‚úÖ Eight Half-Bridges: Each channel handles up to 36V and 1A RMS | ‚úÖ Current and Voltage Regulation: Supports both CDR (Current Drive Regulation) and VDR (Voltage Drive Regulation) modes | ‚úÖ Integrated Current Sensing (ICS): Real-time current monitoring without external sense resistors | ‚úÖ Half-Bridge and Full-Bridge Modes: Flexible bridge configurations | ‚úÖ HIT/HOLD Current Control: Programmable hit current, hold current, and hit time | ‚úÖ Comprehensive Protection: OCP, OL, DPM, UVLO, TSD, and fault registers | ‚úÖ Hardware Agnostic: SPI interface for platform independence | ‚úÖ Modern C++: C++20 with CRTP-based design | ‚úÖ Zero Overhead: CRTP-based design for compile-time polymorphism | ‚úÖ Callback Support: Event-driven programming with fault and state callbacks | ‚úÖ Statistics Tracking: Runtime performance and error monitoring | . ",
    "url": "/hf-max22200-driver/development/#-features",
    
    "relUrl": "/#-features"
  },"4": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üöÄ Quick Start",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 . | #include \"max22200.hpp\" // 1. Implement the SPI interface (see platform_integration.md) class MySpi : public max22200::SpiInterface&lt;MySpi&gt; { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Your SPI transfer implementation } }; // 2. Create driver instance MySpi spi; max22200::MAX22200 driver(spi); // 3. Set board config (IFS from RREF; required for CDR) driver.SetBoardConfig(max22200::BoardConfig(30.0f, false)); // 4. Initialize if (driver.Initialize() == max22200::DriverStatus::OK) { // 5. Configure channel 0 (CDR, low-side) max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 500.0f; // desired current, mA config.hold_setpoint = 200.0f; config.hit_time_ms = 10.0f; config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; driver.ConfigureChannel(0, config); driver.EnableChannel(0); } . | . For detailed setup, see Installation and Quick Start Guide. ",
    "url": "/hf-max22200-driver/development/#-quick-start",
    
    "relUrl": "/#-quick-start"
  },"5": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üîß Installation",
    "content": ". | Clone or copy the driver files into your project | Implement the SPI interface for your platform (see Platform Integration) | Include the header in your code: | 1 . | #include \"max22200.hpp\" . | . | Compile with a C++20 or newer compiler | . For detailed installation instructions, see docs/installation.md. ",
    "url": "/hf-max22200-driver/development/#-installation",
    
    "relUrl": "/#-installation"
  },"6": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üìñ API Reference",
    "content": "| Method | Description | . | Initialize() / Deinitialize() | Initialize or shut down (ENABLE, STATUS ACTIVE) | . | ConfigureChannel() | Configure a channel (CFG_CHx) | . | EnableChannel() / DisableChannel() | Turn a channel on or off | . | EnableAllChannels() / DisableAllChannels() | Turn all channels on or off | . | SetChannelsOn(mask) | Set which channels are on (bitmask) | . | ReadStatus() / WriteStatus() | Read/write STATUS (ONCH, fault masks, ACTIVE) | . | ReadFaultRegister() / ClearAllFaults() | Read or clear per-channel faults (OCP, HHF, OLF, DPM) | . | SetBoardConfig() | Set IFS and limits for mA/% APIs | . | SetHitCurrentMa() / GetHitCurrentMa() | Set/get current in mA (CDR) | . | ConfigureDpm() | Configure plunger movement detection in mA/ms | . | EnableDevice() / DisableDevice() | ENABLE pin on/off | . | SetFaultCallback() | Fault event callback; use FaultTypeToStr() for names | . | GetStatistics() | Driver statistics | . For complete API documentation, see docs/api_reference.md. ",
    "url": "/hf-max22200-driver/development/#-api-reference",
    
    "relUrl": "/#-api-reference"
  },"7": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üìä Examples",
    "content": "For ESP32 examples, see the examples/esp32 directory. Additional examples for other platforms are available in the examples directory. Detailed example walkthroughs are available in docs/examples.md. ",
    "url": "/hf-max22200-driver/development/#-examples",
    
    "relUrl": "/#-examples"
  },"8": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üìö Documentation",
    "content": "For complete documentation, see the docs directory. ",
    "url": "/hf-max22200-driver/development/#-documentation",
    
    "relUrl": "/#-documentation"
  },"9": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "ü§ù Contributing",
    "content": "Pull requests and suggestions are welcome! Please follow the existing code style and include tests for new features. ",
    "url": "/hf-max22200-driver/development/#-contributing",
    
    "relUrl": "/#-contributing"
  },"10": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "üìÑ License",
    "content": "This project is licensed under the GNU General Public License v3.0. See the LICENSE file for details. ",
    "url": "/hf-max22200-driver/development/#-license",
    
    "relUrl": "/#-license"
  },"11": {
    "doc": "HardFOC MAX22200 Driver",
    "title": "HardFOC MAX22200 Driver",
    "content": " ",
    "url": "/hf-max22200-driver/development/",
    
    "relUrl": "/"
  },"12": {
    "doc": "‚öôÔ∏è CMake Integration",
    "title": "MAX22200 ‚Äî CMake Integration Guide",
    "content": "How to consume the MAX22200 driver in your CMake or ESP-IDF project. ",
    "url": "/hf-max22200-driver/development/docs/cmake_integration/#max22200--cmake-integration-guide",
    
    "relUrl": "/docs/cmake_integration/#max22200--cmake-integration-guide"
  },"13": {
    "doc": "‚öôÔ∏è CMake Integration",
    "title": "Quick Start (Generic CMake)",
    "content": "| 1 2 . | add_subdirectory(external/hf-max22200-driver) target_link_libraries(my_app PRIVATE hf::max22200) . | . ",
    "url": "/hf-max22200-driver/development/docs/cmake_integration/#quick-start-generic-cmake",
    
    "relUrl": "/docs/cmake_integration/#quick-start-generic-cmake"
  },"14": {
    "doc": "‚öôÔ∏è CMake Integration",
    "title": "ESP-IDF Integration",
    "content": "Component wrapper: examples/esp32/components/hf_max22200/ . | 1 2 3 4 5 6 . | idf_component_register( SRCS \"app_main.cpp\" INCLUDE_DIRS \".\" REQUIRES hf_max22200 driver ) target_compile_features(${COMPONENT_LIB} PRIVATE cxx_std_20) . | . ",
    "url": "/hf-max22200-driver/development/docs/cmake_integration/#esp-idf-integration",
    
    "relUrl": "/docs/cmake_integration/#esp-idf-integration"
  },"15": {
    "doc": "‚öôÔ∏è CMake Integration",
    "title": "Build Variables",
    "content": "| Variable | Value | . | HF_MAX22200_TARGET_NAME | hf_max22200 | . | HF_MAX22200_VERSION | Current MAJOR.MINOR.PATCH | . | HF_MAX22200_PUBLIC_INCLUDE_DIRS | inc/ + generated header dir | . | HF_MAX22200_SOURCE_FILES | \"\" (header-only) | . | HF_MAX22200_IDF_REQUIRES | driver | . Navigation ‚¨ÖÔ∏è Back to Documentation Index . ",
    "url": "/hf-max22200-driver/development/docs/cmake_integration/#build-variables",
    
    "relUrl": "/docs/cmake_integration/#build-variables"
  },"16": {
    "doc": "‚öôÔ∏è CMake Integration",
    "title": "‚öôÔ∏è CMake Integration",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/cmake_integration/",
    
    "relUrl": "/docs/cmake_integration/"
  },"17": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Configuration",
    "content": "This guide covers configuration options for the MAX22200 driver, aligned with the device registers (STATUS, CFG_CHx, CFG_DPM) and types in max22200_types.hpp. ",
    "url": "/hf-max22200-driver/development/docs/configuration/#configuration",
    
    "relUrl": "/docs/configuration/#configuration"
  },"18": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Channel Configuration (CFG_CHx)",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/configuration/#channel-configuration-cfg_chx",
    
    "relUrl": "/docs/configuration/#channel-configuration-cfg_chx"
  },"19": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Basic Channel Setup",
    "content": "Channels are configured via ChannelConfig and written with ConfigureChannel(). ChannelConfig stores user units (mA for CDR, % for VDR, ms for hit time). For CDR, IFS comes from the board (SetBoardConfig with RREF)‚Äîyou do not set it per channel. Call SetBoardConfig(BoardConfig(rref_kohm, hfs)) first; the driver uses that IFS when writing. The driver gets the master clock (FREQM) from STATUS for hit_time conversion‚Äîyou do not set it on ChannelConfig. Channels are turned on/off via the STATUS register channels_on_mask (ONCH bits) (see Channel Control). | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . | driver.SetBoardConfig(max22200::BoardConfig(30.0f, false)); // IFS from RREF (required for CDR) max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 500.0f; // desired current, mA config.hold_setpoint = 200.0f; // mA config.hit_time_ms = 10.0f; // 10 ms config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; config.hit_current_check_enabled = true; config.open_load_detection_enabled = false; config.plunger_movement_detection_enabled = false; driver.ConfigureChannel(0, config); . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#basic-channel-setup",
    
    "relUrl": "/docs/configuration/#basic-channel-setup"
  },"20": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Drive Modes",
    "content": ". | CDR (Current Drive Regulation) config.drive_mode = max22200::DriveMode::CDR; Regulates current to hit/hold levels. Only supported in low-side mode. | VDR (Voltage Drive Regulation) config.drive_mode = max22200::DriveMode::VDR; Duty-cycle control. Supported in both low-side and high-side. | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#drive-modes",
    
    "relUrl": "/docs/configuration/#drive-modes"
  },"21": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Side Mode (Low-Side vs High-Side)",
    "content": ". | Low-side config.side_mode = max22200::SideMode::LOW_SIDE; Load between OUT and VM. Supports CDR and VDR, HFS, SRC, DPM. When half_full_scale is true, effective IFS for that channel is half of board IFS (driver uses it for mA ‚Üî raw conversion). | High-side config.side_mode = max22200::SideMode::HIGH_SIDE; Load between OUT and GND. VDR only; no CDR, HFS, SRC, or DPM. | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#side-mode-low-side-vs-high-side",
    
    "relUrl": "/docs/configuration/#side-mode-low-side-vs-high-side"
  },"22": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Current and Timing in Real Units",
    "content": "Option A ‚Äî Driver APIs (recommended): Set IFS with BoardConfig, then use mA/ms APIs: . | 1 2 3 4 5 6 7 8 . | max22200::BoardConfig board(30.0f, false); board.max_current_ma = 800; // Optional safety limit (0 = no limit) board.max_duty_percent = 90; // Optional for VDR (0 = no limit) driver.SetBoardConfig(board); driver.SetHitCurrentMa(0, 500); // Channel 0, 500 mA driver.SetHoldCurrentMa(0, 200); driver.SetHitTimeMs(0, 10.0f); // 10 ms (converted from fCHOP) . | . Option B ‚Äî Set user units on ChannelConfig directly: Call SetBoardConfig() first (IFS from RREF). Set hit_setpoint, hold_setpoint, hit_time_ms, and chop_freq. The driver uses board IFS (and STATUS FREQM for hit time) when writing; ChannelConfig does not store IFS or master clock. | 1 2 3 4 5 6 7 8 9 10 . | driver.SetBoardConfig(max22200::BoardConfig(30.0f, false)); // IFS from RREF max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 500.0f; // mA config.hold_setpoint = 200.0f; // mA config.hit_time_ms = 10.0f; config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; driver.ConfigureChannel(0, config); . | . For VDR, set hit_setpoint and hold_setpoint as duty percent (0‚Äì100). Helpers currentMaToRaw(), hitTimeMsToRaw(), and getChopFreqKhz() are in max22200_types.hpp for custom conversion. ",
    "url": "/hf-max22200-driver/development/docs/configuration/#current-and-timing-in-real-units",
    
    "relUrl": "/docs/configuration/#current-and-timing-in-real-units"
  },"23": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Human-Readable Probes on ChannelConfig",
    "content": "You can query config with inline helpers (see max22200_types.hpp): . | config.isCdr() / config.isVdr(), config.isLowSide() / config.isHighSide() | config.hasHitTime(), config.isContinuousHit() (hit_time_ms &gt; 0 or continuous) | config.isHalfFullScale(), config.isSlewRateControlEnabled(), config.isOpenLoadDetectionEnabled(), config.isPlungerMovementDetectionEnabled(), config.isHitCurrentCheckEnabled() | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#human-readable-probes-on-channelconfig",
    
    "relUrl": "/docs/configuration/#human-readable-probes-on-channelconfig"
  },"24": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "STATUS Register (StatusConfig)",
    "content": "The STATUS register holds channel on/off bits (ONCH), fault masks, channel-pair mode (CMxy), and the ACTIVE bit. Read/write with ReadStatus() and WriteStatus(). The driver keeps an internal cache of STATUS (updated on ReadStatus, WriteStatus, and Initialize) for hit-time and duty-limit conversions. If you write STATUS via WriteRegister32(RegBank::STATUS, ...), that cache is not updated‚Äîprefer WriteStatus(StatusConfig) when changing STATUS. ",
    "url": "/hf-max22200-driver/development/docs/configuration/#status-register-statusconfig",
    
    "relUrl": "/docs/configuration/#status-register-statusconfig"
  },"25": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Channel On/Off (ONCH)",
    "content": ". | status.channels_on_mask ‚Äî bitmask: bit N = channel N on (1) or off (0). | Helpers: status.isChannelOn(ch), status.channelCountOn(), status.getChannelsOnMask(). | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#channel-onoff-onch",
    
    "relUrl": "/docs/configuration/#channel-onoff-onch"
  },"26": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Fault Masks (M_OVT, M_OCP, ‚Ä¶)",
    "content": "When a mask bit is 1, that fault does not assert the nFAULT pin. Use the human-readable helpers: . | status.isOvertemperatureMasked(), status.isOvercurrentMasked(), status.isOpenLoadFaultMasked(), status.isHitNotReachedMasked(), status.isPlungerMovementFaultMasked(), status.isCommunicationErrorMasked(), status.isUndervoltageMasked(). | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#fault-masks-m_ovt-m_ocp-",
    
    "relUrl": "/docs/configuration/#fault-masks-m_ovt-m_ocp-"
  },"27": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Fault Flags (Read-Only)",
    "content": "After ReadStatus(status) or ReadFaultFlags(status): . | status.hasOvertemperature(), status.hasOvercurrent(), status.hasOpenLoadFault(), status.hasHitNotReached(), status.hasPlungerMovementFault(), status.hasCommunicationError(), status.hasUndervoltage(), status.hasFault(), status.isActive(). | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#fault-flags-read-only",
    
    "relUrl": "/docs/configuration/#fault-flags-read-only"
  },"28": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Channel-Pair Mode (CM10, CM32, CM54, CM76)",
    "content": "Pairs (0‚Äì1, 2‚Äì3, 4‚Äì5, 6‚Äì7) can be INDEPENDENT, PARALLEL, or HBRIDGE. Change only when both channels in the pair are off. | status.getChannelPairMode10(), getChannelPairMode32(), getChannelPairMode54(), getChannelPairMode76() return ChannelMode. | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#channel-pair-mode-cm10-cm32-cm54-cm76",
    
    "relUrl": "/docs/configuration/#channel-pair-mode-cm10-cm32-cm54-cm76"
  },"29": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Master Frequency (FREQM)",
    "content": ". | status.is100KHzBase() / status.is80KHzBase() ‚Äî base clock for chopping frequency. | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#master-frequency-freqm",
    
    "relUrl": "/docs/configuration/#master-frequency-freqm"
  },"30": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "FAULT Register (FaultStatus)",
    "content": "Per-channel fault bits (OCP, HHF, OLF, DPM) are read with ReadFaultRegister(faults). Reading clears flags (and deasserts nFAULT when no other faults remain). Use human-readable probes: . | faults.hasOvercurrent(), faults.hasHitNotReached(), faults.hasOpenLoadFault(), faults.hasPlungerMovementFault() | faults.hasFaultOnChannel(ch), faults.hasOvercurrentOnChannel(ch), etc. | faults.channelsWithAnyFault() ‚Äî bitmask of channels with any fault. | FaultTypeToStr(fault_type) for logging (e.g. ‚ÄúOvercurrent‚Äù, ‚ÄúHIT not reached‚Äù). | . Clearing: . | ClearAllFaults() ‚Äî clear all and discard. | ClearChannelFaults(channel_mask, &amp;faults) ‚Äî clear selected channels (MAX22200A); optional snapshot in faults. | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#fault-register-faultstatus",
    
    "relUrl": "/docs/configuration/#fault-register-faultstatus"
  },"31": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "DPM Configuration (CFG_DPM)",
    "content": "Plunger movement detection is global; enable per channel with config.plunger_movement_detection_enabled = true (low-side only), or in one call with SetDpmEnabledChannels(channel_mask) (bit N = 1 enables DPM on channel N). Configure algorithm in real units: . | 1 2 . | driver.ConfigureDpm(200.0f, 50.0f, 2.0f); // start_current_ma, dip_threshold_ma, debounce_ms (debounce uses cached STATUS FREQM + FMAIN_DIV4 fCHOP) . | . Or read/write raw DpmConfig (plunger_movement_start_current, plunger_movement_debounce_time, plunger_movement_current_threshold) with ReadDpmConfig() / WriteDpmConfig(). Use getPlungerMovementStartCurrent(), getPlungerMovementDebounceTime(), getPlungerMovementCurrentThreshold() for readable access. ",
    "url": "/hf-max22200-driver/development/docs/configuration/#dpm-configuration-cfg_dpm",
    
    "relUrl": "/docs/configuration/#dpm-configuration-cfg_dpm"
  },"32": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Channel Control",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/configuration/#channel-control",
    
    "relUrl": "/docs/configuration/#channel-control"
  },"33": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Enable/Disable Channels",
    "content": "| 1 2 3 4 5 6 7 8 . | driver.EnableChannel(0); driver.DisableChannel(0); driver.SetChannelEnabled(0, true); // or false driver.EnableAllChannels(); driver.DisableAllChannels(); driver.SetAllChannelsEnabled(true); // or false driver.SetChannelsOn((1u &lt;&lt; 0) | (1u &lt;&lt; 2)); // Channels 0 and 2 on . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#enabledisable-channels",
    
    "relUrl": "/docs/configuration/#enabledisable-channels"
  },"34": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Full-Bridge Pairs",
    "content": "When a pair is configured as HBRIDGE in STATUS (e.g. status.channel_pair_mode_10 = ChannelMode::HBRIDGE), use: . | 1 . | driver.SetFullBridgeState(0, max22200::FullBridgeState::Forward); // pair 0 = ch0‚Äìch1 . | . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#full-bridge-pairs",
    
    "relUrl": "/docs/configuration/#full-bridge-pairs"
  },"35": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Device Enable (ENABLE Pin)",
    "content": "| 1 2 3 . | driver.EnableDevice(); // ENABLE pin high ‚Äî SPI and channels active driver.DisableDevice(); // ENABLE pin low ‚Äî low power driver.SetDeviceEnable(true); // or false . | . Initialization sets ACTIVE=1 and ENABLE high; Deinitialize() sets ACTIVE=0 and ENABLE low. ",
    "url": "/hf-max22200-driver/development/docs/configuration/#device-enable-enable-pin",
    
    "relUrl": "/docs/configuration/#device-enable-enable-pin"
  },"36": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Recommended Setups",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/configuration/#recommended-setups",
    
    "relUrl": "/docs/configuration/#recommended-setups"
  },"37": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Solenoid (CDR, low-side)",
    "content": "| 1 2 3 4 5 6 7 8 9 10 . | max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 800.0f; // mA (IFS from SetBoardConfig) config.hold_setpoint = 200.0f; config.hit_time_ms = 50.0f; config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; config.hit_current_check_enabled = true; driver.ConfigureChannel(0, config); driver.EnableChannel(0); . | . Or use the preset: auto config = max22200::ChannelConfig::makeSolenoidCdr(800.0f, 200.0f, 50.0f); config.hit_current_check_enabled = true; driver.ConfigureChannel(0, config); . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#solenoid-cdr-low-side",
    
    "relUrl": "/docs/configuration/#solenoid-cdr-low-side"
  },"38": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Motor (H-bridge pair)",
    "content": "Set channel pair to ChannelMode::HBRIDGE in STATUS (both channels off), configure both channels, then use SetFullBridgeState(pair_index, Forward) or Reverse, etc. ",
    "url": "/hf-max22200-driver/development/docs/configuration/#motor-h-bridge-pair",
    
    "relUrl": "/docs/configuration/#motor-h-bridge-pair"
  },"39": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Low-Power (VDR)",
    "content": "| 1 2 3 4 5 6 . | config.drive_mode = max22200::DriveMode::VDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 60.0f; // duty % config.hold_setpoint = 20.0f; config.hit_time_ms = 100.0f; config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; . | . Or: auto config = max22200::ChannelConfig::makeSolenoidVdr(60.0f, 20.0f, 100.0f); driver.ConfigureChannel(0, config); . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#low-power-vdr",
    
    "relUrl": "/docs/configuration/#low-power-vdr"
  },"40": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "Next Steps",
    "content": ". | See Examples for full code. | API Reference for all methods and types. | . Navigation ‚¨ÖÔ∏è Platform Integration | Next: API Reference ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-max22200-driver/development/docs/configuration/#next-steps",
    
    "relUrl": "/docs/configuration/#next-steps"
  },"41": {
    "doc": "‚öôÔ∏è Configuration",
    "title": "‚öôÔ∏è Configuration",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/configuration/",
    
    "relUrl": "/docs/configuration/"
  },"42": {
    "doc": "üí° Examples",
    "title": "Examples",
    "content": "Working examples using the current driver API (STATUS, CFG_CHx, FAULT, CFG_DPM, and types in max22200_types.hpp). ",
    "url": "/hf-max22200-driver/development/docs/examples/#examples",
    
    "relUrl": "/docs/examples/#examples"
  },"43": {
    "doc": "üí° Examples",
    "title": "Example 1: Basic Solenoid Control (CDR)",
    "content": "CDR mode, low-side, with hit/hold current and HIT time. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 . | #include \"max22200.hpp\" void app_main() { // SPI setup (implement SpiInterface for your platform) MySpi spi; max22200::MAX22200 driver(spi); if (driver.Initialize() != max22200::DriverStatus::OK) { printf(\"Initialization failed\\n\"); return; } max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 800.0f; // mA config.hold_setpoint = 200.0f; config.hit_time_ms = 50.0f; // IFS from SetBoardConfig; driver uses cached STATUS for hit time config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; config.hit_current_check_enabled = true; driver.ConfigureChannel(0, config); driver.EnableChannel(0); printf(\"Solenoid enabled\\n\"); } . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-1-basic-solenoid-control-cdr",
    
    "relUrl": "/docs/examples/#example-1-basic-solenoid-control-cdr"
  },"44": {
    "doc": "üí° Examples",
    "title": "Example 2: Motor with H-Bridge Pair",
    "content": "Use channel-pair mode HBRIDGE and set full-bridge state. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 . | #include \"max22200.hpp\" void app_main() { MySpi spi; max22200::MAX22200 driver(spi); driver.Initialize(); // Set pair 0 (ch0‚Äìch1) to H-bridge; both channels must be off first max22200::StatusConfig status; driver.ReadStatus(status); status.channels_on_mask = 0; status.channel_pair_mode_10 = max22200::ChannelMode::HBRIDGE; driver.WriteStatus(status); // Configure both channels (forward uses ch1 config, reverse uses ch0) max22200::ChannelConfig cfg; cfg.drive_mode = max22200::DriveMode::CDR; cfg.side_mode = max22200::SideMode::LOW_SIDE; cfg.hit_setpoint = 500.0f; cfg.hold_setpoint = 500.0f; cfg.hit_time_ms = -1.0f; // Continuous // IFS from SetBoardConfig cfg.chop_freq = max22200::ChopFreq::FMAIN_DIV2; driver.ConfigureChannel(0, cfg); driver.ConfigureChannel(1, cfg); // Drive forward driver.SetFullBridgeState(0, max22200::FullBridgeState::Forward); } . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-2-motor-with-h-bridge-pair",
    
    "relUrl": "/docs/examples/#example-2-motor-with-h-bridge-pair"
  },"45": {
    "doc": "üí° Examples",
    "title": "Example 3: Fault Handling and Human-Readable Fault Names",
    "content": "Use ReadFaultRegister, probe helpers, and FaultTypeToStr() for logging. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 . | #include \"max22200.hpp\" void fault_handler(uint8_t channel, max22200::FaultType fault_type, void *user_data) { printf(\"Fault on channel %u: %s\\n\", channel, max22200::FaultTypeToStr(fault_type)); } void app_main() { MySpi spi; max22200::MAX22200 driver(spi); driver.Initialize(); driver.SetFaultCallback(fault_handler); max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 500.0f; config.hold_setpoint = 200.0f; config.hit_time_ms = 10.0f; // IFS from SetBoardConfig; driver uses cached STATUS for hit time config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; driver.ConfigureChannel(0, config); driver.EnableChannel(0); for (;;) { max22200::FaultStatus faults; driver.ReadFaultRegister(faults); if (faults.hasFault()) { printf(\"Faults: %u (mask 0x%02X)\\n\", faults.getFaultCount(), faults.channelsWithAnyFault()); if (faults.hasOvercurrent()) printf(\" Overcurrent\\n\"); if (faults.hasHitNotReached()) printf(\" HIT not reached\\n\"); if (faults.hasOpenLoadFault()) printf(\" Open-load\\n\"); if (faults.hasPlungerMovementFault()) printf(\" Plunger movement\\n\"); } vTaskDelay(pdMS_TO_TICKS(100)); } } . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-3-fault-handling-and-human-readable-fault-names",
    
    "relUrl": "/docs/examples/#example-3-fault-handling-and-human-readable-fault-names"
  },"46": {
    "doc": "üí° Examples",
    "title": "Example 4: Multiple Channels and Status",
    "content": "Use ReadStatus() for channel on/off and ReadFaultRegister() for per-channel faults. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 . | #include \"max22200.hpp\" void app_main() { MySpi spi; max22200::MAX22200 driver(spi); driver.Initialize(); for (uint8_t ch = 0; ch &lt; 8; ch++) { max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 400.0f; config.hold_setpoint = 150.0f; config.hit_time_ms = 10.0f; // IFS from SetBoardConfig; driver uses cached STATUS for hit time config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; driver.ConfigureChannel(ch, config); } driver.SetChannelsOn(0x0F); // Channels 0‚Äì3 on max22200::StatusConfig status; driver.ReadStatus(status); printf(\"Channels on: %u\\n\", status.channelCountOn()); for (uint8_t ch = 0; ch &lt; 8; ch++) { if (status.isChannelOn(ch)) printf(\" Channel %u on\\n\", ch); } max22200::FaultStatus faults; driver.ReadFaultRegister(faults); for (uint8_t ch = 0; ch &lt; 8; ch++) { if (faults.hasFaultOnChannel(ch)) { printf(\" Channel %u fault (OCP=%d HHF=%d OLF=%d DPM=%d)\\n\", ch, faults.hasOvercurrentOnChannel(ch), faults.hasHitNotReachedOnChannel(ch), faults.hasOpenLoadFaultOnChannel(ch), faults.hasPlungerMovementFaultOnChannel(ch)); } } } . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-4-multiple-channels-and-status",
    
    "relUrl": "/docs/examples/#example-4-multiple-channels-and-status"
  },"47": {
    "doc": "üí° Examples",
    "title": "Example 5: Board Config and Current in mA",
    "content": "Set IFS via BoardConfig, then use mA and ms APIs. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 . | #include \"max22200.hpp\" void app_main() { MySpi spi; max22200::MAX22200 driver(spi); driver.Initialize(); max22200::BoardConfig board(30.0f, false); board.max_current_ma = 800; driver.SetBoardConfig(board); driver.ConfigureChannelCdr(0, 500, 200, 10.0f); // 500 mA hit, 200 mA hold, 10 ms driver.EnableChannel(0); uint32_t hit_ma = 0, hold_ma = 0; driver.GetHitCurrentMa(0, hit_ma); driver.GetHoldCurrentMa(0, hold_ma); printf(\"Channel 0: hit=%\" PRIu32 \" mA, hold=%\" PRIu32 \" mA\\n\", hit_ma, hold_ma); } . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-5-board-config-and-current-in-ma",
    
    "relUrl": "/docs/examples/#example-5-board-config-and-current-in-ma"
  },"48": {
    "doc": "üí° Examples",
    "title": "Example 6: ESP32 Solenoid / Valve Test (All 8 Channels)",
    "content": "The solenoid valve test app (max22200_solenoid_valve_test) is a dedicated ESP32 application that exercises the driver on valves with full diagnostics. It uses the same C21-style profile on all 8 channels and runs sequential (follow-up) and parallel clicking patterns. What it does: . | Configures all 8 channels with the same valve profile (C21: 100 ms hit, 50% hold, low-side CDR or VDR per C21ValveConfig). | Sequential pattern: Enables channel 0, holds 200 ms, disables; then ch1 ‚Ä¶ ch7 with 80 ms gap between channels. | Parallel pattern: Turns all channels on for 500 ms, then all off. | Logs full diagnostics after init and after each pattern: . | STATUS (ACTIVE, fault flags, channels on mask) | FAULT register (OCP, HHF, OLF, DPM per channel) | Last fault byte from Command Register (hex + bit decode) | nFAULT pin state | Per-channel config readback (raw register + hit/hold/hit_time, CDR/VDR, LS/HS) | BoardConfig (IFS, max current, max duty) | Driver statistics (transfers, failed, faults, uptime, success %) | . | . Build and run (from examples/esp32): . | 1 2 . | ./scripts/build_app.sh max22200_solenoid_valve_test Debug ./scripts/flash_app.sh max22200_solenoid_valve_test Debug . | . Valve profile (CDR vs VDR, hit/hold, hit time) is set in esp32_max22200_test_config.hpp via C21ValveConfig. See examples/esp32/README.md for the full Solenoid / Valve Test section. ",
    "url": "/hf-max22200-driver/development/docs/examples/#example-6-esp32-solenoid--valve-test-all-8-channels",
    
    "relUrl": "/docs/examples/#example-6-esp32-solenoid--valve-test-all-8-channels"
  },"49": {
    "doc": "üí° Examples",
    "title": "Running the Examples",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/examples/#running-the-examples",
    
    "relUrl": "/docs/examples/#running-the-examples"
  },"50": {
    "doc": "üí° Examples",
    "title": "ESP32",
    "content": "| 1 2 3 . | cd examples/esp32 ./scripts/build_app.sh max22200_comprehensive_test Debug # or max22200_solenoid_valve_test ./scripts/flash_app.sh max22200_comprehensive_test Debug . | . ",
    "url": "/hf-max22200-driver/development/docs/examples/#esp32",
    
    "relUrl": "/docs/examples/#esp32"
  },"51": {
    "doc": "üí° Examples",
    "title": "Other Platforms",
    "content": "Implement max22200::SpiInterface&lt;YourSpi&gt; for your platform and build with C++20. See Platform Integration. ",
    "url": "/hf-max22200-driver/development/docs/examples/#other-platforms",
    
    "relUrl": "/docs/examples/#other-platforms"
  },"52": {
    "doc": "üí° Examples",
    "title": "Next Steps",
    "content": ". | API Reference for all methods and types | Configuration for STATUS, fault masks, and DPM | Troubleshooting for common issues | . Navigation ‚¨ÖÔ∏è API Reference | Next: Troubleshooting ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-max22200-driver/development/docs/examples/#next-steps",
    
    "relUrl": "/docs/examples/#next-steps"
  },"53": {
    "doc": "üí° Examples",
    "title": "üí° Examples",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/examples/",
    
    "relUrl": "/docs/examples/"
  },"54": {
    "doc": "üîå Hardware Setup",
    "title": "Hardware Setup",
    "content": "This guide covers the physical connections and hardware requirements for the MAX22200 octal solenoid and motor driver chip. ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#hardware-setup",
    
    "relUrl": "/docs/hardware_setup/#hardware-setup"
  },"55": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Connections",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#pin-connections",
    
    "relUrl": "/docs/hardware_setup/#pin-connections"
  },"56": {
    "doc": "üîå Hardware Setup",
    "title": "Basic SPI Connections",
    "content": "| 1 2 3 4 5 6 7 8 . | MCU MAX22200 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ VDD GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ GND SCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SCLK MOSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDI MISO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SDO CS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CS . | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#basic-spi-connections",
    
    "relUrl": "/docs/hardware_setup/#basic-spi-connections"
  },"57": {
    "doc": "üîå Hardware Setup",
    "title": "Pin Descriptions",
    "content": "| Pin | Name | Description | Required | . | VDD | Power | 3.3V power supply (2.7V - 5.5V) | Yes | . | GND | Ground | Ground reference | Yes | . | SCLK | Clock | SPI clock line | Yes | . | SDI | Data In | SPI data input (from MCU) | Yes | . | SDO | Data Out | SPI data output (to MCU) | Yes | . | CS | Chip Select | SPI chip select (active low) | Yes | . | FAULT | Fault | Fault interrupt output (optional) | No | . | RESET | Reset | Reset input (optional) | No | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#pin-descriptions",
    
    "relUrl": "/docs/hardware_setup/#pin-descriptions"
  },"58": {
    "doc": "üîå Hardware Setup",
    "title": "Channel Output Pins",
    "content": "Each of the 8 channels has two output pins: . | Channel | OUTA | OUTB | . | 0 | OUT0A | OUT0B | . | 1 | OUT1A | OUT1B | . | 2 | OUT2A | OUT2B | . | 3 | OUT3A | OUT3B | . | 4 | OUT4A | OUT4B | . | 5 | OUT5A | OUT5B | . | 6 | OUT6A | OUT6B | . | 7 | OUT7A | OUT7B | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#channel-output-pins",
    
    "relUrl": "/docs/hardware_setup/#channel-output-pins"
  },"59": {
    "doc": "üîå Hardware Setup",
    "title": "Power Requirements",
    "content": ". | Supply Voltage: 2.7V - 5.5V (3.3V or 5V typical) | Current Consumption: Depends on load, up to 1A RMS per channel | Power Supply: Clean supply with decoupling capacitors (100nF ceramic + 10¬µF tantalum recommended per channel) | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#power-requirements",
    
    "relUrl": "/docs/hardware_setup/#power-requirements"
  },"60": {
    "doc": "üîå Hardware Setup",
    "title": "SPI Configuration",
    "content": ". | Mode: SPI Mode 0 (CPOL=0, CPHA=0) or Mode 3 (CPOL=1, CPHA=1) | Speed: Up to 10 MHz | Bit Order: MSB first | CS Polarity: Active low (CS) | Data Format: 8-bit data words | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#spi-configuration",
    
    "relUrl": "/docs/hardware_setup/#spi-configuration"
  },"61": {
    "doc": "üîå Hardware Setup",
    "title": "Load Connections",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#load-connections",
    
    "relUrl": "/docs/hardware_setup/#load-connections"
  },"62": {
    "doc": "üîå Hardware Setup",
    "title": "Half-Bridge Mode",
    "content": "In half-bridge mode, connect the load between OUTA and GND: . | 1 2 . | OUTA ‚îÄ‚îÄ‚îÄ‚îÄ[Load]‚îÄ‚îÄ‚îÄ‚îÄ GND OUTB ‚îÄ‚îÄ‚îÄ‚îÄ (not used) . | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#half-bridge-mode",
    
    "relUrl": "/docs/hardware_setup/#half-bridge-mode"
  },"63": {
    "doc": "üîå Hardware Setup",
    "title": "Full-Bridge Mode",
    "content": "In full-bridge mode, connect the load between OUTA and OUTB: . | 1 . | OUTA ‚îÄ‚îÄ‚îÄ‚îÄ[Load]‚îÄ‚îÄ‚îÄ‚îÄ OUTB . | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#full-bridge-mode",
    
    "relUrl": "/docs/hardware_setup/#full-bridge-mode"
  },"64": {
    "doc": "üîå Hardware Setup",
    "title": "Physical Layout Recommendations",
    "content": ". | Keep SPI traces short (&lt; 10cm recommended) | Use ground plane for noise reduction | Place decoupling capacitors (100nF ceramic + 10¬µF tantalum) close to VDD pin | Route clock and data lines away from noise sources | Keep high-current traces (OUTA/OUTB) away from sensitive signals | Use appropriate trace widths for high-current paths | Add flyback diodes for inductive loads (solenoids, motors) | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#physical-layout-recommendations",
    
    "relUrl": "/docs/hardware_setup/#physical-layout-recommendations"
  },"65": {
    "doc": "üîå Hardware Setup",
    "title": "Example Wiring Diagram",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 . | MAX22200 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 3.3V ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ VDD ‚îÇ GND ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ GND ‚îÇ SCK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SCLK ‚îÇ MOSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SDI ‚îÇ MISO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SDO ‚îÇ CS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ CS ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ OUT0A ‚îú‚îÄ‚îÄ‚îÄ[Solenoid]‚îÄ‚îÄ‚îÄ GND ‚îÇ ‚îÇ OUT0B (not used in half-bridge) . | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#example-wiring-diagram",
    
    "relUrl": "/docs/hardware_setup/#example-wiring-diagram"
  },"66": {
    "doc": "üîå Hardware Setup",
    "title": "Protection Components",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#protection-components",
    
    "relUrl": "/docs/hardware_setup/#protection-components"
  },"67": {
    "doc": "üîå Hardware Setup",
    "title": "Flyback Diodes",
    "content": "For inductive loads (solenoids, motors), add flyback diodes: . | 1 2 . | OUTA ‚îÄ‚îÄ‚îÄ‚îÄ[Flyback Diode]‚îÄ‚îÄ‚îÄ OUTB (cathode to OUTA) . | . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#flyback-diodes",
    
    "relUrl": "/docs/hardware_setup/#flyback-diodes"
  },"68": {
    "doc": "üîå Hardware Setup",
    "title": "Current Limiting",
    "content": "The MAX22200 has built-in overcurrent protection (OCP), but you may want to add external current limiting for additional safety. ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#current-limiting",
    
    "relUrl": "/docs/hardware_setup/#current-limiting"
  },"69": {
    "doc": "üîå Hardware Setup",
    "title": "Next Steps",
    "content": ". | Verify connections with a multimeter | Proceed to Quick Start to test the connection | Review Platform Integration for software setup | . Navigation ‚¨ÖÔ∏è Quick Start | Next: Platform Integration ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/#next-steps",
    
    "relUrl": "/docs/hardware_setup/#next-steps"
  },"70": {
    "doc": "üîå Hardware Setup",
    "title": "üîå Hardware Setup",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/hardware_setup/",
    
    "relUrl": "/docs/hardware_setup/"
  },"71": {
    "doc": "üìö Documentation",
    "title": "HF-MAX22200 Documentation",
    "content": "Welcome! This directory contains step-by-step guides for installing, building, and using the HF-MAX22200 library. ",
    "url": "/hf-max22200-driver/development/docs/#hf-max22200-documentation",
    
    "relUrl": "/docs/#hf-max22200-documentation"
  },"72": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation Structure",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/#-documentation-structure",
    
    "relUrl": "/docs/#-documentation-structure"
  },"73": {
    "doc": "üìö Documentation",
    "title": "Getting Started",
    "content": ". | üõ†Ô∏è Installation ‚Äì Prerequisites and how to obtain the source | ‚ö° Quick Start ‚Äì Minimal working example to get you running | üîå Hardware Setup ‚Äì Wiring diagrams and pin connections | . ",
    "url": "/hf-max22200-driver/development/docs/#getting-started",
    
    "relUrl": "/docs/#getting-started"
  },"74": {
    "doc": "üìö Documentation",
    "title": "Integration",
    "content": ". | üîß Platform Integration ‚Äì Implement the CRTP SPI interface for your platform | ‚öôÔ∏è Configuration ‚Äì Configuration options and settings | . ",
    "url": "/hf-max22200-driver/development/docs/#integration",
    
    "relUrl": "/docs/#integration"
  },"75": {
    "doc": "üìö Documentation",
    "title": "Reference",
    "content": ". | üìñ API Reference ‚Äì Complete API documentation | üí° Examples ‚Äì Detailed example walkthroughs | . ",
    "url": "/hf-max22200-driver/development/docs/#reference",
    
    "relUrl": "/docs/#reference"
  },"76": {
    "doc": "üìö Documentation",
    "title": "Troubleshooting",
    "content": ". | üêõ Troubleshooting ‚Äì Common issues and solutions | . ",
    "url": "/hf-max22200-driver/development/docs/#troubleshooting",
    
    "relUrl": "/docs/#troubleshooting"
  },"77": {
    "doc": "üìö Documentation",
    "title": "üöÄ Quick Start Path",
    "content": "New to MAX22200? Follow this recommended path: . | Start with Installation to prepare your environment | Follow Hardware Setup to wire your hardware | Read Quick Start for a minimal working example | Check Platform Integration to implement the SPI interface | Explore Examples for more advanced usage | . ",
    "url": "/hf-max22200-driver/development/docs/#-quick-start-path",
    
    "relUrl": "/docs/#-quick-start-path"
  },"78": {
    "doc": "üìö Documentation",
    "title": "üí° Need Help?",
    "content": ". | üêõ Found a bug? Check the Troubleshooting guide | ‚ùì Have questions? Review the API Reference | üìù Want to contribute? See the contributing guidelines in the main README | . Navigation ‚û°Ô∏è Installation . ",
    "url": "/hf-max22200-driver/development/docs/#-need-help",
    
    "relUrl": "/docs/#-need-help"
  },"79": {
    "doc": "üìö Documentation",
    "title": "üìö Documentation",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/",
    
    "relUrl": "/docs/"
  },"80": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Installation",
    "content": "This guide covers how to obtain and integrate the MAX22200 driver library into your project. ",
    "url": "/hf-max22200-driver/development/docs/installation/#installation",
    
    "relUrl": "/docs/installation/#installation"
  },"81": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Prerequisites",
    "content": "Before installing the driver, ensure you have: . | C++20 Compiler: GCC 10+, Clang 12+, or MSVC 2019+ | Build System: Make, CMake, or ESP-IDF (depending on your platform) | Platform SDK: ESP-IDF, STM32 HAL, Arduino, or your platform‚Äôs SPI driver | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#prerequisites",
    
    "relUrl": "/docs/installation/#prerequisites"
  },"82": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Obtaining the Source",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/installation/#obtaining-the-source",
    
    "relUrl": "/docs/installation/#obtaining-the-source"
  },"83": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 1: Git Clone",
    "content": "| 1 2 . | git clone https://github.com/n3b3x/hf-max22200-driver.git cd hf-max22200-driver . | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#option-1-git-clone",
    
    "relUrl": "/docs/installation/#option-1-git-clone"
  },"84": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Option 2: Copy Files",
    "content": "Copy the following files into your project: . | 1 2 3 4 5 6 7 . | inc/ ‚îú‚îÄ‚îÄ max22200.hpp ‚îú‚îÄ‚îÄ max22200_spi_interface.hpp ‚îú‚îÄ‚îÄ max22200_registers.hpp ‚îî‚îÄ‚îÄ max22200_types.hpp src/ ‚îî‚îÄ‚îÄ max22200.cpp . | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#option-2-copy-files",
    
    "relUrl": "/docs/installation/#option-2-copy-files"
  },"85": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Integration Methods",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/installation/#integration-methods",
    
    "relUrl": "/docs/installation/#integration-methods"
  },"86": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Using CMake",
    "content": "Add the driver as a subdirectory in your CMakeLists.txt: . | 1 2 3 4 5 . | add_subdirectory(external/hf-max22200-driver) target_link_libraries(your_target PRIVATE hf_max22200) target_include_directories(your_target PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/external/hf-max22200-driver/inc ) . | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#using-cmake",
    
    "relUrl": "/docs/installation/#using-cmake"
  },"87": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Using ESP-IDF Component",
    "content": "The driver can be used as an ESP-IDF component. Add it to your components directory: . | 1 2 3 4 5 6 . | # In your main CMakeLists.txt idf_component_register( SRCS \"your_code.cpp\" INCLUDE_DIRS \".\" REQUIRES hf_max22200 ) . | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#using-esp-idf-component",
    
    "relUrl": "/docs/installation/#using-esp-idf-component"
  },"88": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Manual Integration",
    "content": ". | Copy the driver files to your project | Add the inc/ directory to your include path | Include the header: | 1 . | #include \"max22200.hpp\" . | . | Compile with C++20 support: | 1 . | g++ -std=c++20 -I inc/ your_code.cpp src/max22200.cpp . | . | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#manual-integration",
    
    "relUrl": "/docs/installation/#manual-integration"
  },"89": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Verification",
    "content": "To verify the installation: . | Include the header in a test file: | 1 . | #include \"max22200.hpp\" . | . | Compile a simple test: | 1 . | g++ -std=c++20 -I inc/ -c src/max22200.cpp -o test.o . | . | If compilation succeeds, the library is properly installed. | . ",
    "url": "/hf-max22200-driver/development/docs/installation/#verification",
    
    "relUrl": "/docs/installation/#verification"
  },"90": {
    "doc": "üõ†Ô∏è Installation",
    "title": "Next Steps",
    "content": ". | Follow the Quick Start guide to create your first application | Review Hardware Setup for wiring instructions | Check Platform Integration to implement the SPI interface | . Navigation ‚¨ÖÔ∏è Back to Index | Next: Quick Start ‚û°Ô∏è . ",
    "url": "/hf-max22200-driver/development/docs/installation/#next-steps",
    
    "relUrl": "/docs/installation/#next-steps"
  },"91": {
    "doc": "üõ†Ô∏è Installation",
    "title": "üõ†Ô∏è Installation",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/installation/",
    
    "relUrl": "/docs/installation/"
  },"92": {
    "doc": "üîß Platform Integration",
    "title": "Platform Integration Guide",
    "content": "This guide explains how to implement the hardware abstraction interface for the MAX22200 driver on your platform. ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#platform-integration-guide",
    
    "relUrl": "/docs/platform_integration/#platform-integration-guide"
  },"93": {
    "doc": "üîß Platform Integration",
    "title": "Understanding CRTP (Curiously Recurring Template Pattern)",
    "content": "The MAX22200 driver uses CRTP (Curiously Recurring Template Pattern) for hardware abstraction. This design choice provides several critical benefits for embedded systems: . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern",
    
    "relUrl": "/docs/platform_integration/#understanding-crtp-curiously-recurring-template-pattern"
  },"94": {
    "doc": "üîß Platform Integration",
    "title": "Why CRTP Instead of Virtual Functions?",
    "content": "1. Zero Runtime Overhead . | Virtual functions: Require a vtable lookup (indirect call) = ~5-10 CPU cycles overhead per call | CRTP: Direct function calls = 0 overhead, compiler can inline | Impact: In time-critical embedded code controlling solenoids/motors, this matters significantly | . 2. Compile-Time Polymorphism . | Virtual functions: Runtime dispatch - the compiler cannot optimize across the abstraction boundary | CRTP: Compile-time dispatch - full optimization, dead code elimination, constant propagation | Impact: Smaller code size, faster execution | . 3. Memory Efficiency . | Virtual functions: Each object needs a vtable pointer (4-8 bytes) | CRTP: No vtable pointer needed | Impact: Critical in memory-constrained systems | . 4. Type Safety . | Virtual functions: Runtime errors if method not implemented | CRTP: Compile-time errors if method not implemented | Impact: Catch bugs at compile time, not in the field | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#why-crtp-instead-of-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#why-crtp-instead-of-virtual-functions"
  },"95": {
    "doc": "üîß Platform Integration",
    "title": "How CRTP Works",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 . | // Base template class (from max22200_spi_interface.hpp) template &lt;typename Derived&gt; class SpiInterface { public: bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { // Cast 'this' to Derived* and call the derived implementation return static_cast&lt;Derived*&gt;(this)-&gt;Transfer(tx_data, rx_data, length); } }; // Your implementation class MySPI : public max22200::SpiInterface&lt;MySPI&gt; { public: // This method is called directly (no virtual overhead) bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { // Your platform-specific SPI code } }; ```cpp ## Interface Definition The MAX22200 driver requires you to implement the following interface: ```cpp template &lt;typename Derived&gt; class SpiInterface { public: // Required methods (implement all of these) bool Initialize(); bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length); void SetChipSelect(bool state); bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first = true); bool IsReady() const; }; ```cpp ## Implementation Steps ### Step 1: Create Your Implementation Class ```cpp #include \"max22200_spi_interface.hpp\" class MyPlatformSPI : public max22200::SpiInterface&lt;MyPlatformSPI&gt; { private: // Your platform-specific members spi_device_handle_t spi_device_; // Example for ESP32 public: // Constructor MyPlatformSPI(spi_device_handle_t device) : spi_device_(device) {} // Implement required methods bool Initialize() { // Your initialization code return true; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { // Your transfer code return true; } void SetChipSelect(bool state) { // Your CS control code } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // Your configuration code return true; } bool IsReady() const { // Check if SPI is ready return true; } }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#how-crtp-works",
    
    "relUrl": "/docs/platform_integration/#how-crtp-works"
  },"96": {
    "doc": "üîß Platform Integration",
    "title": "Step 2: Platform-Specific Examples",
    "content": "ESP32 (ESP-IDF) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 . | #include \"driver/spi_master.h\" #include \"max22200_spi_interface.hpp\" class Esp32SPIBus : public max22200::SpiInterface&lt;Esp32SPIBus&gt; { private: spi_device_handle_t spi_device_; gpio_num_t cs_pin_; public: Esp32SPIBus(spi_host_device_t host, const spi_device_interface_config_t&amp; config, gpio_num_t cs) { spi_bus_add_device(host, &amp;config, &amp;spi_device_); cs_pin_ = cs; } bool Initialize() { return spi_device_ != nullptr; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { spi_transaction_t trans = {}; trans.length = length * 8; trans.tx_buffer = tx_data; trans.rx_buffer = rx_data; esp_err_t ret = spi_device_transmit(spi_device_, &amp;trans); return ret == ESP_OK; } void SetChipSelect(bool state) { gpio_set_level(cs_pin_, state ? 0 : 1); // Active low } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // ESP-IDF handles this via device config return true; } bool IsReady() const { return spi_device_ != nullptr; } }; . | . STM32 (HAL) . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 . | #include \"stm32f4xx_hal.h\" #include \"max22200_spi_interface.hpp\" extern SPI_HandleTypeDef hspi1; class STM32SPIBus : public max22200::SpiInterface&lt;STM32SPIBus&gt; { private: GPIO_TypeDef* cs_port_; uint16_t cs_pin_; public: STM32SPIBus(GPIO_TypeDef* cs_port, uint16_t cs_pin) : cs_port_(cs_port), cs_pin_(cs_pin) {} bool Initialize() { return HAL_SPI_Init(&amp;hspi1) == HAL_OK; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { SetChipSelect(true); // Assert CS HAL_StatusTypeDef status = HAL_SPI_TransmitReceive(&amp;hspi1, (uint8_t*)tx_data, rx_data, length, HAL_MAX_DELAY); SetChipSelect(false); // Deassert CS return status == HAL_OK; } void SetChipSelect(bool state) { HAL_GPIO_WritePin(cs_port_, cs_pin_, state ? GPIO_PIN_RESET : GPIO_PIN_SET); } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // STM32 HAL handles this via SPI init return true; } bool IsReady() const { return hspi1.State == HAL_SPI_STATE_READY; } }; . | . Arduino . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 . | #include &lt;SPI.h&gt; #include \"max22200_spi_interface.hpp\" class ArduinoSPIBus : public max22200::SpiInterface&lt;ArduinoSPIBus&gt; { private: uint8_t cs_pin_; public: ArduinoSPIBus(uint8_t cs_pin) : cs_pin_(cs_pin) { pinMode(cs_pin_, OUTPUT); digitalWrite(cs_pin_, HIGH); } bool Initialize() { SPI.begin(); return true; } bool Transfer(const uint8_t* tx_data, uint8_t* rx_data, size_t length) { SPI.beginTransaction(SPISettings(10000000, MSBFIRST, SPI_MODE0)); SetChipSelect(true); for (size_t i = 0; i &lt; length; i++) { uint8_t byte = SPI.transfer(tx_data ? tx_data[i] : 0); if (rx_data) { rx_data[i] = byte; } } SetChipSelect(false); SPI.endTransaction(); return true; } void SetChipSelect(bool state) { digitalWrite(cs_pin_, state ? LOW : HIGH); // Active low } bool Configure(uint32_t speed_hz, uint8_t mode, bool msb_first) { // Arduino SPI handles this via beginTransaction return true; } bool IsReady() const { return true; } }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#step-2-platform-specific-examples",
    
    "relUrl": "/docs/platform_integration/#step-2-platform-specific-examples"
  },"97": {
    "doc": "üîß Platform Integration",
    "title": "Common Pitfalls",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#common-pitfalls",
    
    "relUrl": "/docs/platform_integration/#common-pitfalls"
  },"98": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Use Virtual Functions",
    "content": "| 1 2 3 4 5 6 7 . | // WRONG - defeats the purpose of CRTP class MyBus : public max22200::SpiInterface&lt;MyBus&gt; { public: virtual bool Transfer(...) override { // ‚ùå Virtual keyword not needed // ... } }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#-dont-use-virtual-functions",
    
    "relUrl": "/docs/platform_integration/#-dont-use-virtual-functions"
  },"99": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct CRTP Implementation",
    "content": "| 1 2 3 4 5 6 7 . | // CORRECT - no virtual keyword class MyBus : public max22200::SpiInterface&lt;MyBus&gt; { public: bool Transfer(...) { // ‚úÖ Direct implementation // ... } }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#-correct-crtp-implementation",
    
    "relUrl": "/docs/platform_integration/#-correct-crtp-implementation"
  },"100": {
    "doc": "üîß Platform Integration",
    "title": "‚ùå Don‚Äôt Forget the Template Parameter",
    "content": "| 1 2 3 4 . | // WRONG - missing template parameter class MyBus : public max22200::SpiInterface { // ‚ùå Compiler error // ... }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#-dont-forget-the-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-dont-forget-the-template-parameter"
  },"101": {
    "doc": "üîß Platform Integration",
    "title": "‚úÖ Correct Template Parameter",
    "content": "| 1 2 3 4 . | // CORRECT - pass your class as template parameter class MyBus : public max22200::SpiInterface&lt;MyBus&gt; { // ‚úÖ // ... }; . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#-correct-template-parameter",
    
    "relUrl": "/docs/platform_integration/#-correct-template-parameter"
  },"102": {
    "doc": "üîß Platform Integration",
    "title": "Testing Your Implementation",
    "content": "After implementing the interface, test it: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . | MyPlatformSPI spi(/* your config */); max22200::MAX22200 driver(spi); if (driver.Initialize() == max22200::DriverStatus::OK) { max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 500.0f; config.hold_setpoint = 200.0f; config.hit_time_ms = 10.0f; // IFS from SetBoardConfig (not set on ChannelConfig) config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; driver.ConfigureChannel(0, config); driver.EnableChannel(0); } . | . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#testing-your-implementation",
    
    "relUrl": "/docs/platform_integration/#testing-your-implementation"
  },"103": {
    "doc": "üîß Platform Integration",
    "title": "Next Steps",
    "content": ". | See Configuration for driver configuration options | Check Examples for complete usage examples | Review API Reference for all available methods | . Navigation ‚¨ÖÔ∏è Hardware Setup | Next: Configuration ‚û°Ô∏è . ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/#next-steps",
    
    "relUrl": "/docs/platform_integration/#next-steps"
  },"104": {
    "doc": "üîß Platform Integration",
    "title": "üîß Platform Integration",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/platform_integration/",
    
    "relUrl": "/docs/platform_integration/"
  },"105": {
    "doc": "‚ö° Quick Start",
    "title": "Quick Start",
    "content": "This guide will get you up and running with the MAX22200 driver in just a few steps. ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#quick-start",
    
    "relUrl": "/docs/quickstart/#quick-start"
  },"106": {
    "doc": "‚ö° Quick Start",
    "title": "Prerequisites",
    "content": ". | Driver installed | Hardware wired | SPI interface implemented | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#prerequisites",
    
    "relUrl": "/docs/quickstart/#prerequisites"
  },"107": {
    "doc": "‚ö° Quick Start",
    "title": "Minimal Example",
    "content": "Here‚Äôs a complete working example: . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 . | #include \"max22200.hpp\" // 1. Implement the SPI interface class MySpi : public max22200::SpiInterface&lt;MySpi&gt; { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Your SPI transfer implementation // Assert CS, transfer data, deassert CS } }; // 2. Create instances MySpi spi; max22200::MAX22200 driver(spi); // 3. Initialize if (driver.Initialize() == max22200::DriverStatus::OK) { // 4. Configure channel 0 (CDR, low-side; user units: mA and ms) max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 500.0f; // 500 mA config.hold_setpoint = 200.0f; // 200 mA config.hit_time_ms = 10.0f; // 10 ms // IFS from SetBoardConfig; driver uses STATUS FREQM for hit time config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; config.hit_current_check_enabled = true; // Enable HIT current check driver.ConfigureChannel(0, config); driver.EnableChannel(0); } . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#minimal-example",
    
    "relUrl": "/docs/quickstart/#minimal-example"
  },"108": {
    "doc": "‚ö° Quick Start",
    "title": "Step-by-Step Explanation",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-by-step-explanation",
    
    "relUrl": "/docs/quickstart/#step-by-step-explanation"
  },"109": {
    "doc": "‚ö° Quick Start",
    "title": "Step 1: Include the Header",
    "content": "| 1 . | #include \"max22200.hpp\" . | . This includes the main driver class and all necessary types. ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-1-include-the-header",
    
    "relUrl": "/docs/quickstart/#step-1-include-the-header"
  },"110": {
    "doc": "‚ö° Quick Start",
    "title": "Step 2: Implement the SPI Interface",
    "content": "You need to implement the SpiInterface for your platform. See Platform Integration for detailed examples. | 1 2 3 4 5 6 7 8 . | class MySpi : public max22200::SpiInterface&lt;MySpi&gt; { public: void transfer(const uint8_t* tx, uint8_t* rx, size_t len) { // Assert chip select // Perform SPI transfer // Deassert chip select } }; . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-2-implement-the-spi-interface",
    
    "relUrl": "/docs/quickstart/#step-2-implement-the-spi-interface"
  },"111": {
    "doc": "‚ö° Quick Start",
    "title": "Step 3: Create Driver Instance",
    "content": "| 1 2 . | MySpi spi; max22200::MAX22200 driver(spi); . | . The constructor takes a reference to your SPI interface implementation. ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-3-create-driver-instance",
    
    "relUrl": "/docs/quickstart/#step-3-create-driver-instance"
  },"112": {
    "doc": "‚ö° Quick Start",
    "title": "Step 4: Initialize",
    "content": "| 1 2 3 . | if (driver.Initialize() == max22200::DriverStatus::OK) { // Driver is ready } . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-4-initialize",
    
    "relUrl": "/docs/quickstart/#step-4-initialize"
  },"113": {
    "doc": "‚ö° Quick Start",
    "title": "Step 5: Configure Channel",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 . | max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 500.0f; // 500 mA (CDR) config.hold_setpoint = 200.0f; // 200 mA config.hit_time_ms = 10.0f; // 10 ms // IFS from SetBoardConfig; driver uses cached STATUS for hit time config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; config.hit_current_check_enabled = true; driver.ConfigureChannel(0, config); . | . Alternatively, set board config first then use convenience APIs: . | 1 2 3 4 . | max22200::BoardConfig board(30.0f, false); // IFS from RREF driver.SetBoardConfig(board); driver.SetHitCurrentMa(0, 500); // Channel 0, 500 mA driver.SetHoldCurrentMa(0, 200); . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-5-configure-channel",
    
    "relUrl": "/docs/quickstart/#step-5-configure-channel"
  },"114": {
    "doc": "‚ö° Quick Start",
    "title": "Step 6: Enable Channel",
    "content": "| 1 . | driver.EnableChannel(0); . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#step-6-enable-channel",
    
    "relUrl": "/docs/quickstart/#step-6-enable-channel"
  },"115": {
    "doc": "‚ö° Quick Start",
    "title": "Complete Example with Error Handling",
    "content": "| 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 . | #include \"max22200.hpp\" class MySpi : public max22200::SpiInterface&lt;MySpi&gt; { // ... SPI implementation }; void app_main() { MySpi spi; max22200::MAX22200 driver(spi); // Initialize max22200::DriverStatus status = driver.Initialize(); if (status != max22200::DriverStatus::OK) { printf(\"Initialization failed\\n\"); return; } // Configure channel (user units: mA and ms) max22200::ChannelConfig config; config.drive_mode = max22200::DriveMode::CDR; config.side_mode = max22200::SideMode::LOW_SIDE; config.hit_setpoint = 500.0f; config.hold_setpoint = 200.0f; config.hit_time_ms = 10.0f; config.chop_freq = max22200::ChopFreq::FMAIN_DIV2; status = driver.ConfigureChannel(0, config); if (status != max22200::DriverStatus::OK) { printf(\"Channel configuration failed\\n\"); return; } // Enable channel driver.EnableChannel(0); // Read configured current in mA (requires SetBoardConfig with IFS) uint32_t current_ma = 0; if (driver.GetHitCurrentMa(0, current_ma) == max22200::DriverStatus::OK) { printf(\"Channel 0 hit current: %\" PRIu32 \" mA\\n\", current_ma); } } . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#complete-example-with-error-handling",
    
    "relUrl": "/docs/quickstart/#complete-example-with-error-handling"
  },"116": {
    "doc": "‚ö° Quick Start",
    "title": "Expected Output",
    "content": "When running this example (with SetBoardConfig set for your IFS), you should see the configured current in mA, for example: . | 1 . | Channel 0 hit current: 500 mA . | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#expected-output",
    
    "relUrl": "/docs/quickstart/#expected-output"
  },"117": {
    "doc": "‚ö° Quick Start",
    "title": "Troubleshooting",
    "content": "If you encounter issues: . | Compilation errors: Check that you‚Äôve implemented the transfer() method in your SPI interface | Initialization fails: Verify SPI connections and hardware setup | Channel not working: Check channel configuration and enable state | See: Troubleshooting for common issues | . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#troubleshooting",
    
    "relUrl": "/docs/quickstart/#troubleshooting"
  },"118": {
    "doc": "‚ö° Quick Start",
    "title": "Next Steps",
    "content": ". | Explore Examples for more advanced usage | Review the API Reference for all available methods | Check Configuration for customization options | . Navigation ‚¨ÖÔ∏è Installation | Next: Hardware Setup ‚û°Ô∏è | Back to Index . ",
    "url": "/hf-max22200-driver/development/docs/quickstart/#next-steps",
    
    "relUrl": "/docs/quickstart/#next-steps"
  },"119": {
    "doc": "‚ö° Quick Start",
    "title": "‚ö° Quick Start",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/quickstart/",
    
    "relUrl": "/docs/quickstart/"
  },"120": {
    "doc": "üêõ Troubleshooting",
    "title": "Troubleshooting",
    "content": "This guide helps you diagnose and resolve common issues when using the MAX22200 driver. For a detailed analysis of SPI command bytes, write/read byte order, and decoding (and why raw register HEX comparison is used for pass/fail), see SPI Protocol Analysis. ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#troubleshooting",
    
    "relUrl": "/docs/troubleshooting/#troubleshooting"
  },"121": {
    "doc": "üêõ Troubleshooting",
    "title": "Common Error Messages",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#common-error-messages",
    
    "relUrl": "/docs/troubleshooting/#common-error-messages"
  },"122": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Initialization Failed",
    "content": "Symptoms: . | Initialize() returns INITIALIZATION_ERROR | Driver not responding | . Causes: . | SPI interface not properly initialized | Hardware connections incorrect | Power supply issues | . Solutions: . | Verify SPI Interface: Ensure SPI interface is initialized before creating driver | Check Connections: Verify all SPI connections (SCLK, SDI, SDO, CS) | Verify Power: Check power supply voltage (2.7V - 5.5V) | Check CS Line: Verify chip select is properly controlled | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#error-initialization-failed",
    
    "relUrl": "/docs/troubleshooting/#error-initialization-failed"
  },"123": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Communication Error",
    "content": "Symptoms: . | COMMUNICATION_ERROR returned from methods | No response from device | . Causes: . | SPI configuration incorrect | Signal integrity issues | CS timing problems | . Solutions: . | Check SPI Mode: Ensure SPI Mode 0 or Mode 3 | Verify Speed: Try lower SPI speed (e.g., 1 MHz) | Check CS Timing: Verify CS assertion/deassertion timing | Verify Connections: Check all SPI connections are secure | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#error-communication-error",
    
    "relUrl": "/docs/troubleshooting/#error-communication-error"
  },"124": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Channel Not Working",
    "content": "Symptoms: . | Channel enabled but no output | Current not flowing | . Causes: . | Channel not properly configured | Channel not enabled | Load not connected correctly | Fault condition | . Solutions: . | Check Configuration: Verify channel configuration is correct | Check Enable State: Ensure channel is enabled via EnableChannel() | Verify Load: Check load connections (OUTA/OUTB to load) | Check Faults: Read fault status to identify issues | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#error-channel-not-working",
    
    "relUrl": "/docs/troubleshooting/#error-channel-not-working"
  },"125": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Overcurrent Protection (OCP)",
    "content": "Symptoms: . | FaultStatus::hasOvercurrent() is true (or per-channel hasOvercurrentOnChannel(ch)) | nFAULT pin asserted; channel may be disabled depending on mask | . Causes: . | Load current exceeds limits | Short circuit | Incorrect current settings | . Solutions: . | Check Load: Verify load is within specifications (1A RMS max per channel) | Reduce Current: Lower hit_setpoint and hold_setpoint (or use set_hit_ma/set_hold_ma or SetHitCurrentMa/SetHoldCurrentMa) | Check for Shorts: Verify no short circuits in wiring | Clear Fault: Read fault status to clear, then reconfigure | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#error-overcurrent-protection-ocp",
    
    "relUrl": "/docs/troubleshooting/#error-overcurrent-protection-ocp"
  },"126": {
    "doc": "üêõ Troubleshooting",
    "title": "Error: Open Load Detection",
    "content": "Symptoms: . | FaultStatus.open_load is true | No current flow | . Causes: . | Load not connected | Broken connection | Load impedance too high | . Solutions: . | Check Connections: Verify load is properly connected | Check Wiring: Inspect for broken wires | Verify Load: Ensure load impedance is appropriate | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#error-open-load-detection",
    
    "relUrl": "/docs/troubleshooting/#error-open-load-detection"
  },"127": {
    "doc": "üêõ Troubleshooting",
    "title": "Hardware Issues",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#hardware-issues",
    
    "relUrl": "/docs/troubleshooting/#hardware-issues"
  },"128": {
    "doc": "üêõ Troubleshooting",
    "title": "Device Not Responding",
    "content": "Checklist: . | Verify power supply voltage is 2.7V - 5.5V | Check all SPI connections are secure | Verify CS line is properly controlled | Check for short circuits | Use oscilloscope/logic analyzer to verify bus activity | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#device-not-responding",
    
    "relUrl": "/docs/troubleshooting/#device-not-responding"
  },"129": {
    "doc": "üêõ Troubleshooting",
    "title": "Incorrect Current Readings",
    "content": "Symptoms: . | Current readings don‚Äôt match expected values | ICS readings are zero or incorrect | . Causes: . | ICS not enabled | Channel not active | Incorrect configuration | . Solutions: . | Enable ICS: Call SetIntegratedCurrentSensing(true) | Check Channel State: Verify channel is enabled and active | Verify Configuration: Check current settings are correct | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#incorrect-current-readings",
    
    "relUrl": "/docs/troubleshooting/#incorrect-current-readings"
  },"130": {
    "doc": "üêõ Troubleshooting",
    "title": "Software Issues",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#software-issues",
    
    "relUrl": "/docs/troubleshooting/#software-issues"
  },"131": {
    "doc": "üêõ Troubleshooting",
    "title": "Compilation Errors",
    "content": "Error: ‚ÄúNo matching function‚Äù . Solution: . | Ensure you‚Äôve implemented all required SPI interface methods | Check method signatures match the interface definition | . Error: ‚ÄúUndefined reference‚Äù . Solution: . | Verify you‚Äôre linking the driver source file | Check include paths are correct | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#compilation-errors",
    
    "relUrl": "/docs/troubleshooting/#compilation-errors"
  },"132": {
    "doc": "üêõ Troubleshooting",
    "title": "Runtime Errors",
    "content": "Initialization Fails . Checklist: . | SPI bus interface is properly initialized | Hardware connections are correct | Configuration parameters are valid | Device is powered and ready | . Unexpected Behavior . Checklist: . | Verify configuration matches your use case | Check for timing issues | Review error handling code | Check fault status | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#runtime-errors",
    
    "relUrl": "/docs/troubleshooting/#runtime-errors"
  },"133": {
    "doc": "üêõ Troubleshooting",
    "title": "Debugging Tips",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#debugging-tips",
    
    "relUrl": "/docs/troubleshooting/#debugging-tips"
  },"134": {
    "doc": "üêõ Troubleshooting",
    "title": "Enable Diagnostics",
    "content": "| 1 . | max22200::MAX22200 driver(spi, true); // Enable diagnostics . | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#enable-diagnostics",
    
    "relUrl": "/docs/troubleshooting/#enable-diagnostics"
  },"135": {
    "doc": "üêõ Troubleshooting",
    "title": "Check Fault Status",
    "content": "| 1 2 3 4 5 6 . | max22200::FaultStatus faults; driver.ReadFaultRegister(faults); if (faults.hasFault()) { printf(\"Faults detected: %d\\n\", faults.getFaultCount()); } . | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#check-fault-status",
    
    "relUrl": "/docs/troubleshooting/#check-fault-status"
  },"136": {
    "doc": "üêõ Troubleshooting",
    "title": "Read Channel and Fault Status",
    "content": "Use STATUS for channel on/off and FAULT for per-channel fault flags: . | 1 2 3 4 5 6 7 8 9 10 11 12 . | max22200::StatusConfig status; driver.ReadStatus(status); bool ch0_on = status.isChannelOn(0); max22200::FaultStatus faults; driver.ReadFaultRegister(faults); bool ch0_fault = faults.hasFaultOnChannel(0); if (faults.hasOvercurrent()) { /* ... */ } // Configured current in mA (after SetBoardConfig) uint32_t hit_ma = 0; driver.GetHitCurrentMa(0, hit_ma); . | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#read-channel-and-fault-status",
    
    "relUrl": "/docs/troubleshooting/#read-channel-and-fault-status"
  },"137": {
    "doc": "üêõ Troubleshooting",
    "title": "Use Callbacks",
    "content": "Set up fault callbacks to get notified immediately when faults occur: . | 1 2 3 4 5 . | void fault_handler(uint8_t channel, max22200::FaultType fault_type, void *user_data) { printf(\"Fault on channel %d\\n\", channel); } driver.SetFaultCallback(fault_handler); . | . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#use-callbacks",
    
    "relUrl": "/docs/troubleshooting/#use-callbacks"
  },"138": {
    "doc": "üêõ Troubleshooting",
    "title": "FAQ",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#faq",
    
    "relUrl": "/docs/troubleshooting/#faq"
  },"139": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What is the maximum current per channel?",
    "content": "A: Each channel can handle up to 1A RMS. ChannelConfig stores currents in user units: for CDR use hit_setpoint and hold_setpoint in mA; call SetBoardConfig(BoardConfig(rref, hfs)) first so the driver uses board IFS and converts to the device‚Äôs 7-bit (0‚Äì127) range when writing. ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#q-what-is-the-maximum-current-per-channel",
    
    "relUrl": "/docs/troubleshooting/#q-what-is-the-maximum-current-per-channel"
  },"140": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: Can I use multiple channels simultaneously?",
    "content": "A: Yes, all 8 channels can be used simultaneously. Each channel is independent. ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#q-can-i-use-multiple-channels-simultaneously",
    
    "relUrl": "/docs/troubleshooting/#q-can-i-use-multiple-channels-simultaneously"
  },"141": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What‚Äôs the difference between CDR and VDR modes?",
    "content": "A: CDR (Current Drive Regulation) regulates current during both hit and hold phases. VDR (Voltage Drive Regulation) applies constant voltage during hit phase and regulates current during hold phase. ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#q-whats-the-difference-between-cdr-and-vdr-modes",
    
    "relUrl": "/docs/troubleshooting/#q-whats-the-difference-between-cdr-and-vdr-modes"
  },"142": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: How do I clear a fault?",
    "content": "A: Read the fault status register to clear latched faults. Some faults (like OCP) may require reconfiguring the channel. ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#q-how-do-i-clear-a-fault",
    
    "relUrl": "/docs/troubleshooting/#q-how-do-i-clear-a-fault"
  },"143": {
    "doc": "üêõ Troubleshooting",
    "title": "Q: What is Integrated Current Sensing (ICS)?",
    "content": "A: ICS allows reading the actual current flowing through each channel without external sense resistors. Enable it with SetIntegratedCurrentSensing(true). ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#q-what-is-integrated-current-sensing-ics",
    
    "relUrl": "/docs/troubleshooting/#q-what-is-integrated-current-sensing-ics"
  },"144": {
    "doc": "üêõ Troubleshooting",
    "title": "Getting More Help",
    "content": "If you‚Äôre still experiencing issues: . | Check the API Reference for method details | Review Examples for working code | Search existing issues on GitHub | Open a new issue with: . | Description of the problem | Steps to reproduce | Hardware setup details | Error messages/logs | . | . Navigation ‚¨ÖÔ∏è Examples | Back to Index . ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/#getting-more-help",
    
    "relUrl": "/docs/troubleshooting/#getting-more-help"
  },"145": {
    "doc": "üêõ Troubleshooting",
    "title": "üêõ Troubleshooting",
    "content": " ",
    "url": "/hf-max22200-driver/development/docs/troubleshooting/",
    
    "relUrl": "/docs/troubleshooting/"
  },"146": {
    "doc": "API Reference",
    "title": "API Reference",
    "content": "# API Reference Reference for the MAX22200 driver public API. For register-level detail see `max22200_registers.hpp` and the datasheet. ## Source Code - **Main header**: [`inc/max22200.hpp`](../inc/max22200.hpp) - **SPI interface**: [`inc/max22200_spi_interface.hpp`](../inc/max22200_spi_interface.hpp) - **Types**: [`inc/max22200_types.hpp`](../inc/max22200_types.hpp) ## Core Class: `MAX22200` Template parameter: `SpiType` ‚Äî your SPI implementation (must inherit `max22200::SpiInterface`). **Constructor:** `explicit MAX22200(SpiType &spi_interface);` --- ## Methods ### Initialization | Method | Description |--------|-------------| `Initialize()` | Full init per datasheet: ENABLE high, read STATUS (clear UVM), write STATUS (ACTIVE=1), cache STATUS | `Deinitialize()` | Disable all channels, ACTIVE=0, ENABLE low | `IsInitialized()` | Returns whether driver is initialized | ### STATUS Register | Method | Description |--------|-------------| `ReadStatus(StatusConfig &status)` | Read 32-bit STATUS | `WriteStatus(const StatusConfig &status)` | Write STATUS (writable bits only) | ### Channel Configuration | Method | Description |--------|-------------| `ConfigureChannel(uint8_t channel, const ChannelConfig &config)` | Write full CFG_CHx for channel | `GetChannelConfig(uint8_t channel, ChannelConfig &config)` | Read channel config | `ConfigureAllChannels(const ChannelConfigArray &configs)` | Configure all 8 channels | `GetAllChannelConfigs(ChannelConfigArray &configs)` | Read all channel configs | ### Channel Control | Method | Description |--------|-------------| `EnableChannel(uint8_t channel)` | Set ONCH bit for channel | `DisableChannel(uint8_t channel)` | Clear ONCH bit | `SetChannelEnabled(uint8_t channel, bool enable)` | Turn channel on/off by bool | `EnableAllChannels()` | Set all ONCH bits | `DisableAllChannels()` | Clear all ONCH bits | `SetAllChannelsEnabled(bool enable)` | All channels on or off | `SetChannelsOn(uint8_t channel_mask)` | Set ONCH from bitmask (bit N = channel N) | `SetFullBridgeState(uint8_t pair_index, FullBridgeState state)` | Set HiZ/Forward/Reverse/Brake for pair 0‚Äì3 | ### Faults | Method | Description |--------|-------------| `ReadFaultRegister(FaultStatus &faults)` | Read FAULT register (OCP/HHF/OLF/DPM per channel); read clears flags | `ClearAllFaults()` | Clear all fault flags (read FAULT, discard) | `ClearChannelFaults(uint8_t channel_mask, FaultStatus *out)` | Clear faults for selected channels (MAX22200A); optional snapshot | `ReadFaultRegisterSelectiveClear(...)` | Advanced: per-type clear masks (MAX22200A) | `ReadFaultFlags(StatusConfig &status)` | Read fault flags from STATUS | `ClearFaultFlags()` | Clear by reading STATUS | `GetFaultPinState(bool &fault_active)` | Read nFAULT pin | `GetLastFaultByte()` | STATUS[7:0] from last Command Register write (e.g. COMER = 0x04) | ### DPM | Method | Description |--------|-------------| `ConfigureDpm(float start_current_ma, float dip_threshold_ma, float debounce_ms)` | Set DPM in mA and ms (uses board IFS) | `ReadDpmConfig(DpmConfig &config)` | Read CFG_DPM | `WriteDpmConfig(const DpmConfig &config)` | Write CFG_DPM | `SetDpmEnabledChannels(uint8_t channel_mask)` | Enable (bit=1) or disable (bit=0) DPM per channel; other channel settings unchanged | ### Device Control | Method | Description |--------|-------------| `EnableDevice()` | ENABLE pin high | `DisableDevice()` | ENABLE pin low | `SetDeviceEnable(bool enable)` | Set ENABLE pin | ### Board and Convenience APIs | Method | Description |--------|-------------| `SetBoardConfig(const BoardConfig &config)` | Set IFS and optional max current/duty limits | `GetBoardConfig()` | Get current board config | **Current (CDR):** `SetHitCurrentMa`, `SetHoldCurrentMa`, `SetHitCurrentA`, `SetHoldCurrentA`, `SetHitCurrentPercent`, `SetHoldCurrentPercent`, `GetHitCurrentMa`, `GetHoldCurrentMa`, `GetHitCurrentPercent`, `GetHoldCurrentPercent` **Duty (VDR):** `SetHitDutyPercent`, `SetHoldDutyPercent`, `GetHitDutyPercent`, `GetHoldDutyPercent` `GetDutyLimits(bool master_clock_80khz, ChopFreq chop_freq, bool slew_rate_control_enabled, DutyLimits &limits)` (static), `GetDutyLimits(uint8_t channel, DutyLimits &limits)` (instance: uses channel config + cached STATUS) **HIT time:** `SetHitTimeMs(uint8_t channel, float ms)`, `GetHitTimeMs(uint8_t channel, float &ms)` **One-shot config:** `ConfigureChannelCdr(channel, hit_ma, hold_ma, hit_time_ms, ...)`, `ConfigureChannelVdr(channel, hit_duty_percent, hold_duty_percent, hit_time_ms, ...)` ### Raw Registers (Debug) | Method | Description |--------|-------------| `ReadRegister32(uint8_t bank, uint32_t &value)` | Read 32-bit register | `WriteRegister32(uint8_t bank, uint32_t value)` | Write 32-bit register (writing STATUS does not update driver cache; prefer WriteStatus) | `ReadRegister8(uint8_t bank, uint8_t &value)` | Read 8-bit MSB | `WriteRegister8(uint8_t bank, uint8_t value)` | Write 8-bit MSB | ### Statistics and Callbacks | Method | Description |--------|-------------| `GetStatistics()` | Return DriverStatistics (transfers, faults, uptime, etc.) | `ResetStatistics()` | Reset statistics | `SetFaultCallback(FaultCallback, void *user_data)` | Fault event callback | `SetStateChangeCallback(StateChangeCallback, void *user_data)` | State change callback | ### Validation | Method | Description |--------|-------------| `IsValidChannel(uint8_t channel)` | Static: true if channel ` | `FaultCallback` | `void (*)(uint8_t channel, FaultType fault_type, void *user_data)` | `StateChangeCallback` | `void (*)(uint8_t channel, ChannelState old_state, ChannelState new_state, void *user_data)` | ### Helper Functions | Function | Description |----------|-------------| `DriverStatusToStr(DriverStatus s)` | Human-readable status string | `FaultTypeToStr(FaultType ft)` | Human-readable fault name (e.g. \"Overcurrent\", \"HIT not reached\") | --- **Navigation** ‚¨ÖÔ∏è [Configuration](/hf-max22200-driver/development/docs/configuration/) | [Next: Examples ‚û°Ô∏è](/hf-max22200-driver/development/docs/examples/) | [Back to Index](/hf-max22200-driver/development/docs/) ",
    "url": "/hf-max22200-driver/development/docs/api_reference.html",
    
    "relUrl": "/docs/api_reference.html"
  },"147": {
    "doc": "SPI Protocol and Decode Analysis",
    "title": "SPI Protocol and Decode Analysis",
    "content": "# SPI Protocol and Decode Analysis This document describes how the driver maps to the MAX22200 SPI protocol (datasheet Rev 1, 3/25), how commands and data are sent/received, and how to verify behavior from logs. It also explains why **raw register comparison** is the right source of truth for write/read tests. --- ## 1. Command byte (Table 9) Every register access starts with one **SPI(1)** transfer (CMD pin high). The byte we **send (TX)** is the Command Register: | Bit | Name | Meaning |------|------------|--------| 7 | RB/W | 0 = Read, 1 = Write | 6:5 | RFU | 0 | 4:1 | A_BNK | Register bank 0x00‚Äì0x0A (STATUS, CFG_CH0‚Äì7, FAULT, CFG_DPM) | 0 | 8bit/n32 | 0 = 32-bit transfer, 1 = 8-bit (MSB only) | **Decoding examples from your log:** | TX (hex) | Decode | Meaning |----------|--------|--------| 0x00 | Read, bank 0, 32-bit | Read STATUS | 0x80 | Write, bank 0, 32-bit | Write STATUS | 0x02 | Read, bank 1, 32-bit | Read CFG_CH0 | 0x82 | Write, bank 1, 32-bit | Write CFG_CH0 | 0x12 | Read, bank 9, 32-bit | Read FAULT | 0x14 | Read, bank 10, 32-bit | Read CFG_DPM | **RX on that same SPI(1)** is the fault flags byte STATUS[7:0] from the device (e.g. 0x03 = no COMER; bit 0 = ACTIVE, bit 1 = UVM, etc.). --- ## 2. Data phase: write (Figure 10) - **SDI (we send):** LSB first ‚Üí first byte = DATAIN[7:0], then [15:8], [23:16], [31:24]. - Driver sends: `tx[0] = value & 0xFF`, `tx[1] = (value>>8)&0xFF`, `tx[2] = (value>>16)&0xFF`, `tx[3] = (value>>24)&0xFF`. **Example ‚Äì Write CFG_CH0 0x28500600:** - SPI(4) TX: `00 06 50 28` ‚Üí bytes [7:0]=0x00, [15:8]=0x06, [23:16]=0x50, [31:24]=0x28 ‚Üí value 0x28500600. Correct. - SDO (we receive) during write: STATUS[7:0], REGCMD, 0x00, 0x00 ‚Üí e.g. `03 82 00 00` (fault byte 0x03, command echo 0x82). Correct. --- ## 3. Data phase: read (Figure 11) - **SDO (we receive):** MSB first ‚Üí first byte = DATA[31:24], then [23:16], [15:8], [7:0]. - Driver assembles: `value = (rx[0]<<24) | (rx[1]<<16) | (rx[2]<<8) | rx[3]`. **Example ‚Äì Read CFG_CH0 back:** - SPI(4) RX: `28 50 06 00` ‚Üí value = 0x28500600. Correct. So **write LSB-first, read MSB-first** matches the datasheet and your log. --- ## 4. Decoding STATUS (0x00040003) - RX bytes (MSB first): 00 04 00 03 ‚Üí value = **0x00040003**. - Byte 3 [31:24] = 0x00 ‚Üí channels_on_mask = 0. - Byte 2 [23:16] = 0x04 ‚Üí fault masks / FREQM (e.g. one mask bit set). - Byte 1 [15:8] = 0x00 ‚Üí channel-pair modes. - Byte 0 [7:0] = 0x03 ‚Üí ACTIVE=1 (bit 0), UVM=1 (bit 1), others 0. So: ACTIVE=1, UVM=1, channels_on=0x00. Matches log. --- ## 5. Decoding CFG_CH0 (0x28500600) - 0x28 = byte 3: HFS=0, HOLD[6:0] = 0x28 (40 decimal) ‚Üí hold current 40/127 √ó IFS. - 0x50 = byte 2: TRGnSPI=0, HIT[6:0] = 0x50 (80 decimal) ‚Üí hit current 80/127 √ó IFS. - 0x06 = byte 1: HIT_T = 6 ‚Üí hit time = 6√ó40/fCHOP (e.g. ~9.6 ms at 25 kHz). - 0x00 = byte 0: VDRnCDR=0 (CDR), HSnLS=0 (low-side), etc. So the **register value** is correct; the **decoded** hit_time_ms (e.g. 9.60 ms) differs from the **requested** 10.0 ms only because of 8-bit quantization (one LSB ‚âà 40/fCHOP ms). --- ## 6. Why compare raw register value (HEX) - **Raw register** = exactly what was written and read over SPI. If `sent_val == raw_val` (e.g. 0x28500600 == 0x28500600), the protocol and byte order are correct. - **Decoded** values (mA, %, ms) come from the same raw value via formulas (IFS, fCHOP, etc.). Small differences (e.g. 10.0 ms vs 9.60 ms) are expected when the stored quantity is quantized. So for **pass/fail of ‚Äúdid the register round-trip?‚Äù** we should compare **raw HEX** (sent vs read). Decoded comparison is still useful for debugging when raw does **not** match, but it should not fail the test when raw matches and the only difference is quantization in user units. The channel_configuration test therefore: 1. Compares **sent_val** to **raw_val** (from `ReadRegister32`). If equal ‚Üí **pass** (register round-trip OK). 2. If raw differs, it then reports decoded field mismatches and fails. This gives a clear, unambiguous check: same HEX ‚Üí SPI and decoding of the register value are correct; any remaining difference in ‚Äú10.00 vs 9.60 ms‚Äù is quantization, not a protocol or decode bug. ",
    "url": "/hf-max22200-driver/development/docs/spi_protocol_analysis.html",
    
    "relUrl": "/docs/spi_protocol_analysis.html"
  },"148": {
    "doc": "MAX22200 ESP32-C6 Comprehensive Test Suite",
    "title": "MAX22200 ESP32-C6 Comprehensive Test Suite",
    "content": "# MAX22200 ESP32-C6 Comprehensive Test Suite This directory contains comprehensive test suites for the MAX22200 octal solenoid and motor driver using the ESP32-C6 DevKit-M-1. ## üìã Table of Contents - [Hardware Overview](#-hardware-overview) - [Pin Connections](#-pin-connections) - [Hardware Setup](#-hardware-setup) - [Building the Tests](#-building-the-tests) - [Running the Tests](#-running-the-tests) - [Test Suites](#-test-suites) - [Troubleshooting](#-troubleshooting) --- ## üîå Hardware Overview ### ESP32-C6 DevKit-M-1 The ESP32-C6 DevKit-M-1 serves as the host controller for communicating with the MAX22200 driver via SPI. ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ESP32-C6 DevKit-M-1 ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ ESP32-C6 Microcontroller ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ GPIO Pins: ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ SPI: MOSI (GPIO7), MISO (GPIO2), ‚îÇ ‚îÇ ‚îÇ ‚îÇ SCLK (GPIO6), CS (GPIO10) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Test Indicator: GPIO14 ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ USB-C Connector ‚îÇ ‚îÇ (Power + Serial Communication) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` ### MAX22200 Octal Solenoid and Motor Driver The MAX22200 is an octal (eight-channel) solenoid and motor driver featuring: - **Eight Half-Bridges**: Each capable of handling up to 36V and 1A RMS - **Current and Voltage Regulation**: Supports both CDR and VDR modes - **Integrated Lossless Current Sensing (ICS)**: Real-time current monitoring - **High-Speed SPI Interface**: Up to 10MHz communication - **Comprehensive Protection**: OCP, OL, DPM, UVLO, TSD, and fault registers ``` ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ MAX22200 Octal Driver ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îÇ ‚îÇ MAX22200 IC ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ Features: ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ 8 half-bridge channels (OUT0-OUT7) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ SPI interface (up to 10MHz) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Current regulation (CDR mode) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Voltage regulation (VDR mode) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Integrated current sensing (ICS) ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Fault detection and reporting ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚Ä¢ Thermal shutdown protection ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ SPI Connections: ‚îÇ ‚îÇ ‚Ä¢ MOSI (Master Out Slave In) ‚îÇ ‚îÇ ‚Ä¢ MISO (Master In Slave Out) ‚îÇ ‚îÇ ‚Ä¢ SCLK (Serial Clock) ‚îÇ ‚îÇ ‚Ä¢ CS (Chip Select) ‚îÇ ‚îÇ ‚îÇ ‚îÇ Power Connections: ‚îÇ ‚îÇ ‚Ä¢ VCC (3.3V/5V Logic Power) ‚îÇ ‚îÇ ‚Ä¢ VDD (12V-36V Load Power) ‚îÇ ‚îÇ ‚Ä¢ GND (Ground) ‚îÇ ‚îÇ ‚îÇ ‚îÇ Control Pins: ‚îÇ ‚îÇ ‚Ä¢ RESET (Reset Input) ‚îÇ ‚îÇ ‚Ä¢ FAULT (Fault Status Output) ‚îÇ ‚îÇ ‚Ä¢ DIAG (Diagnostic Output) ‚îÇ ‚îÇ ‚Ä¢ SHDN (Shutdown Input) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ``` --- ## üìå Pin Connections ### SPI Bus Connections | MAX22200 Pin | ESP32-C6 GPIO | Function | Notes |--------------|---------------|----------|-------| MOSI | GPIO7 | SPI Data Out | Master to Slave | MISO | GPIO2 | SPI Data In | Slave to Master | SCLK | GPIO6 | SPI Clock | Clock signal | CS | GPIO10 | Chip Select | Active low | VCC | 3.3V | Logic Power | 3.3V or 5V | VDD | 12V-36V | Load Power | For solenoids/motors | GND | GND | Ground | Common ground | RESET | GPIO5 (optional) | Reset Input | Active low | FAULT | GPIO4 (optional) | Fault Status | Open-drain, requires pull-up | DIAG | GPIO3 (optional) | Diagnostic | Open-drain, requires pull-up | SHDN | GPIO1 (optional) | Shutdown | Active low | ### Test Indicator | Signal | ESP32-C6 GPIO | Function |--------|---------------|----------| Test Progress | GPIO14 | Visual test progression indicator | ### SPI Configuration Default SPI configuration (can be modified in test file): - **Mode**: Mode 0 (CPOL=0, CPHA=0) or Mode 3 (CPOL=1, CPHA=1) - **Bit Order**: MSB first - **Clock Speed**: Up to 10MHz (5MHz with daisy chaining) - **Data Width**: 8-bit transfers - **Chip Select**: Active low, controlled by software --- ## üõ†Ô∏è Hardware Setup ### Basic Setup 1. **Connect SPI Bus**: - Connect MAX22200 MOSI to ESP32-C6 GPIO7 - Connect MAX22200 MISO to ESP32-C6 GPIO2 - Connect MAX22200 SCLK to ESP32-C6 GPIO6 - Connect MAX22200 CS to ESP32-C6 GPIO10 2. **Power Connections**: - Connect MAX22200 VCC to ESP32-C6 3.3V (logic power) - Connect MAX22200 VDD to 12V-36V power supply (load power) - Connect MAX22200 GND to ESP32-C6 GND (common ground) 3. **Optional Control Pins**: - Connect MAX22200 RESET to ESP32-C6 GPIO5 (optional, can use software reset) - Connect MAX22200 FAULT to ESP32-C6 GPIO4 (optional, for fault monitoring) - Connect MAX22200 DIAG to ESP32-C6 GPIO3 (optional, for diagnostics) - Connect MAX22200 SHDN to ESP32-C6 GPIO1 (optional, for hardware shutdown) 4. **Load Connections**: - Connect solenoids or motors to OUT0-OUT7 pins - Ensure proper current ratings (max 1A RMS per channel) - Use appropriate flyback diodes for inductive loads ### Test Setup For comprehensive testing, you can connect: - Solenoids or motors to output channels (with appropriate current ratings) - Current measurement equipment for ICS verification - Logic analyzer on SPI bus for protocol verification - Oscilloscope for timing analysis --- ## üöÄ Building the Tests ### Prerequisites 1. **Install ESP-IDF** (if not already installed): ```bash # Clone ESP-IDF git clone --recursive https://github.com/espressif/esp-idf.git cd esp-idf # Checkout release version 5.5 git checkout release/v5.5 git submodule update --init --recursive # Install ESP-IDF (Linux/macOS) ./install.sh esp32c6 # Set up environment (add to ~/.bashrc or ~/.zshrc for persistence) ./export.sh ``` 2. **Navigate to ESP32 Examples**: ```bash cd examples/esp32 ``` 3. **Setup Repository** (First time only): ```bash # Make scripts executable and setup the build environment chmod +x scripts/*.sh ./scripts/setup_repo.sh ``` ### Available Test Applications The test suites use a centralized build system with scripts. Available applications: | **Application Name** | **Description** | **Hardware Required** |----------------------|----------------|----------------------| `max22200_comprehensive_test` | Comprehensive MAX22200 driver testing with all features | MAX22200 board | `max22200_solenoid_valve_test` | Solenoid/valve test: all 8 channels, C21 hit/hold, sequential & parallel patterns, full diagnostics | MAX22200 board + valves (optional) | ### List Available Applications ```bash # List all available applications ./scripts/build_app.sh list ``` ### Build an Application ```bash # Build comprehensive test (Debug build) ./scripts/build_app.sh max22200_comprehensive_test Debug # Build comprehensive test (Release build) ./scripts/build_app.sh max22200_comprehensive_test Release ``` --- ## üì§ Running the Tests ### Flash Application ```bash # Flash the application to ESP32-C6 ./scripts/flash_app.sh max22200_comprehensive_test Debug # Or manually: idf.py -p /dev/ttyUSB0 flash ``` ### Monitor Output ```bash # Monitor serial output idf.py -p /dev/ttyUSB0 monitor # Or use the flash script which includes monitoring ./scripts/flash_app.sh max22200_comprehensive_test Debug ``` ### Auto-detect Port ```bash # The scripts can auto-detect the port ./scripts/detect_ports.sh ``` --- ## üß™ Test Suites ### Comprehensive Test Suite **Application**: `max22200_comprehensive_test` This comprehensive test suite validates all MAX22200 functionality: #### Test Sections 1. **Initialization Tests** - SPI bus initialization - Driver initialization - Reset to default state - Global configuration 2. **Channel Configuration Tests** - Single channel configuration - Multiple channel configuration - All channels configuration - Channel enable/disable 3. **Current Control Tests** - Hit current setting - Hold current setting - Current reading (ICS) - Current regulation (CDR mode) 4. **Voltage Control Tests** - Voltage regulation (VDR mode) - Voltage setting and reading 5. **Drive Mode Tests** - CDR (Current Drive Regulation) mode - VDR (Voltage Drive Regulation) mode - Bridge mode configuration 6. **Fault Detection Tests** - Overcurrent protection (OCP) - Overload (OL) detection - Dynamic power management (DPM) - Thermal shutdown (TSD) - Under-voltage lockout (UVLO) 7. **Diagnostic Tests** - Diagnostic mode enable/disable - Fault status reading - Fault callback registration 8. **Statistics Tests** - Operation statistics tracking - Error counting - Performance metrics 9. **Error Handling Tests** - Invalid channel handling - Error flag management - Error recovery 10. **Stress Tests** - Rapid channel operations - Continuous read/write cycles - Multi-channel simultaneous operations #### Test Configuration You can enable/disable specific test sections by editing the test file: ```cpp // In MAX22200ComprehensiveTest.cpp static constexpr bool ENABLE_BASIC_TESTS = true; // ... etc ``` #### Test Results The test framework provides: - Automatic pass/fail tracking - Execution time measurement - GPIO14 progress indicator (toggles on each test) - Comprehensive test summary - Success percentage calculation ### Solenoid / Valve Test **Application**: `max22200_solenoid_valve_test` Dedicated full driver check on valves. Configures **all 8 channels** with the same C21-style profile (100 ms hit, 50% hold, low-side CDR or VDR per `C21ValveConfig` in `esp32_max22200_test_config.hpp`). Runs synchronized patterns and logs comprehensive diagnostics. #### Features - **Same valve profile on all channels**: Hit time 100 ms, hold 50%, CDR or VDR at compile time. - **Sequential pattern**: Follow-up clicking ‚Äî ch0 ‚Üí ch1 ‚Üí ‚Ä¶ ‚Üí ch7 (each on 200 ms, 80 ms gap). - **Parallel pattern**: All 8 channels on together for 500 ms, then all off. - **Full diagnostics**: STATUS (ACTIVE, fault flags, channels on), FAULT register (OCP, HHF, OLF, DPM per channel), last fault byte (hex + decode), nFAULT pin state, per-channel config readback, board config, driver statistics. Formatted logging with section headers and tables for easy interpretation. #### Build and run ```bash ./scripts/build_app.sh max22200_solenoid_valve_test Debug ./scripts/flash_app.sh max22200_solenoid_valve_test Debug ``` #### Configuration Valve profile is controlled by `C21ValveConfig` in `esp32_max22200_test_config.hpp`: `USE_CDR`, `HIT_TIME_MS`, `HOLD_PERCENT`, `HIT_PERCENT`. Timing constants (e.g. `SEQUENTIAL_HIT_MS`, `PARALLEL_HOLD_MS`) are in `max22200_solenoid_valve_test.cpp`. --- ## üîß Configuration ### SPI Bus Configuration Default SPI configuration (can be modified in test file): ```cpp // SPI configuration for MAX22200 // Mode: 0 (CPOL=0, CPHA=0) or 3 (CPOL=1, CPHA=1) // Speed: Up to 10MHz // Bit Order: MSB first ``` ### MAX22200 Configuration Default MAX22200 settings (can be modified in test file): ```cpp // Global configuration GlobalConfig global_config; global_config.diagnostic_enable = true; global_config.ics_enable = true; global_config.daisy_chain_mode = false; global_config.sleep_mode = false; // Channel configuration (user units: mA and ms) ChannelConfig channel_config; channel_config.drive_mode = DriveMode::CDR; channel_config.side_mode = SideMode::LOW_SIDE; channel_config.hit_setpoint = 500.0f; // mA channel_config.hold_setpoint = 200.0f; // mA channel_config.hit_time_ms = 10.0f; // IFS from SetBoardConfig; driver uses cached STATUS for hit time channel_config.chop_freq = ChopFreq::FMAIN_DIV2; ``` --- ## üêõ Troubleshooting ### SPI Communication Failures **Symptoms**: Tests fail with SPI errors **Solutions**: 1. **Check SPI connections**: - Verify MOSI/MISO/SCLK/CS connections - Ensure proper power connections - Check for loose connections 2. **Verify SPI configuration**: - Check SPI mode (0 or 3) - Verify clock speed (reduce if using long wires) - Ensure CS is properly controlled 3. **Verify power supply**: - Ensure 3.3V logic power is stable - Check 12V-36V load power is present - Check for voltage drops ### Build Errors **Symptoms**: CMake or compilation errors **Solutions**: 1. **Verify ESP-IDF version**: ```bash idf.py --version # Should show ESP-IDF v5.5 or compatible ``` 2. **Clean and rebuild**: ```bash idf.py fullclean ./scripts/build_app.sh max22200_comprehensive_test Debug ``` 3. **Check component paths**: - Verify component CMakeLists.txt paths - Ensure source files are accessible ### Test Failures **Symptoms**: Specific tests fail **Solutions**: 1. **Check hardware connections**: - Verify all pins are properly connected - Check for loose connections - Verify load connections (solenoids/motors) 2. **Review test logs**: - Check which specific test failed - Review error messages in serial output 3. **Verify device state**: - Reset MAX22200 (power cycle or software reset) - Run reset test first 4. **Check current/voltage settings**: - Verify current settings are within limits (max 1A RMS) - Check voltage supply is within range (12V-36V) --- ## üìö Additional Resources - [MAX22200 Datasheet](/hf-max22200-driver/development/docs/datasheet/MAX22200.pdf) - [Driver API Documentation](/hf-max22200-driver/development/docs/api_reference.html) - [Hardware Integration Guide](../../docs/hardware_guide.md) - [ASCII Diagrams](../../docs/ascii_diagrams.md) --- ## üéØ Quick Reference ### Build Commands ```bash # List available apps ./scripts/build_app.sh list # Build comprehensive test ./scripts/build_app.sh max22200_comprehensive_test Debug # Flash and monitor ./scripts/flash_app.sh max22200_comprehensive_test Debug ``` ### Test Execution The comprehensive test suite runs automatically on boot and provides: - Real-time test progress via GPIO14 indicator - Serial output with detailed test results - Automatic test summary at completion ### GPIO14 Test Indicator GPIO14 toggles between HIGH/LOW for each completed test, providing visual feedback: - Use oscilloscope or logic analyzer to monitor - Useful for automated test verification - Blinks 5 times at section start/end --- ## üìù Notes - **SPI Configuration**: Use Mode 0 or Mode 3, MSB first, up to 10MHz clock - **Power Requirements**: 3.3V/5V for logic, 12V-36V for load power - **Current Limits**: Maximum 1A RMS per channel - **Test Duration**: Comprehensive test suite takes approximately 2-5 minutes to complete - **Hardware Requirements**: Basic tests work without external hardware; some tests require solenoids/motors connected --- üéØ Ready to test the MAX22200? Start with: ./scripts/build_app.sh max22200_comprehensive_test Debug ",
    "url": "/hf-max22200-driver/development/examples/esp32/",
    
    "relUrl": "/examples/esp32/"
  }
}
